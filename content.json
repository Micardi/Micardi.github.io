{"meta":{"title":"Micardi","subtitle":null,"description":null,"author":"Micardi","url":"https://micardi.github.io","root":"/"},"pages":[{}],"posts":[{"title":"教程合集","date":"2019-04-08T08:25:13.183Z","path":"2019/04/08/教程合集/","text":"不知道到底应该是“辑”还是“集” 以下按照个人学习经历，会推荐一些好的博文供大家学习借鉴。当然如果大家觉得我写更好那就太棒啦QwQ。 欸可是你现在什么都没写啊QAQ。 数据结构线段树 CSDN个人认为网络上关于线段树讲的最好的没有之一。其中还包括了ZKW线段树与主席树的讲解，绝对良心QwQ。虽然CSDN是真的恶心。 博客园没有上一篇全面，但内容对新手很友好。重要的是博客园界面显然比CSDN好太多。 树状数组 博客园胡学姐所有博客都很良心啊QwQ！这一篇适合有树状数组基础的同学阅读，简单明快。 CSDN又是万恶的CSDN相较于上一篇更加详细，更适合小白阅读。不过如果已经比较熟练了看起来就觉得有些过于详细。 分块 hzwer关于分块就无脑添加黄学长的链接了。分块入门1-9已成经典QwQ。 另外如果对分块感兴趣的同学可以刷一刷Ynoi 平衡树 博客园关于Splay的不错讲解。不过伸展树这东西建议大家一定要结合代码画图理解。 Link-Cut Tree 博客园个人心目中动态树讲的最好的博文，并且内附LCT应用讲解的链接，十分良心。 树链剖分 博客园树剖大全啦可以算是。 字符串KMP NOI2014动物园认真的，KMP的核心思想这道题和它的题解阐述的非常棒。 博客园也同样很精炼，适合初学者认真研读思考。 其实关于KMP我建议各位去找Peter_Matthew要PPT Trie树 博客园非常详细了…虽然只是一个小知识点。 AC自动机 博客园AC自动机也需要大量画图和思考才能方便理解。 后缀数组 博客园attack讲的后缀数组已经非常良心了，不过这东西本身会有些难懂，个人也要多琢磨琢磨。 百度文库既然提到后缀数组就不能少了罗穗骞的论文。 后缀自动机 Luogu很美妙的算法，应该是字符串算法中最难理解透彻的了。这篇文章较之同类讲解更适合入门与拓展。 数学相关计数问题 Luogu组合数学经典讲解，几乎涵盖了组合数学所有的基础内容，墙裂推荐！ Luogu关于容斥很不错的讲解，不过数学公式略多初学者可能看着会有些头疼QwQ。 数论 博客园关于exgcd的基础讲解，式子推的很工整，不过内容较少。 CSDN关于exgcd较之上一篇讲的更加详细。 博客园关于逆元十分详细并且清楚的讲解。 博客园难得对欧拉筛有证明的文章… 博客园莫比乌斯反演的讲解要力推pengym！包括整除分块、杜教筛也可以看他的博客。 博客园crt和excrt本身就是数论中相对较难推演的算法，建议大家结合博文自行演算几遍。 博客园bsgs与exbsgs，但没有提及正确性。要对简单证明感兴趣可以 戳这里。 线性代数 博客园矩阵乘法与矩阵快速幂入门好文。 menci线性基中蕴含了线代的思想所以我就把menci的线性基讲解放在这里了…说实话menci讲得有一点点过于正式，或许不太好懂？不过的确是教科书般的模范好文。在此无耻自荐Micardi的讲解 github高一神犇XD同学关于行列式、矩阵树的讲解！个人觉得还是很不错的QwQ。不过因为这部分知识本身就不好理解，建议大家也要多多自行演算。 博客园关于行列式/矩阵树的另一份不错讲解，十分详细，适合入门。 关于高斯消元我建议大家看看luogu题解就差不多了 图论 博客园tarjan的好讲解。个人觉得tarjan算法重在画图理解，理解了实现起来十分简单。 博客园二分图与匈牙利的良心讲解，介绍了很多好题与基础模型、定理。 Luogu2-sat感觉要成冷门算法了…不过通过这篇博文略知一二也是不错的QwQ。 博客园玄学网络流玄学讲解QwQ通过这篇由浅入深的博客，感性理解Dinic吧！ 博客园费用流好文嗷。 博客园网络流难在建模，这篇文章给出了很多经典例题供大家学习参考。 概率期望 博客园概率期望网上相关讲解很少，建议大家最好从纯数学角度去打好基础，多做题目。而大米饼这篇博客大概是我见过关于期望概率dp讲解最详细的文章了。 多项式相关 博客园真的是再通俗易懂不过的fft讲解了。同时会了FFT之后NTT就跟背板子无异了。 博弈论 CSDN史上最全面的博弈论讲解了大概。不过这东西考了大家估计也都不会毕竟SG函数是个太玄学的东西了。 其它莫队 博客园美妙的指针在路径上跳来跳去，祝您达到顶尖~ cdq分治&amp;&amp;整体二分 博客园cdq分治这东西初次接触可能不好理解，不过stdcall这篇博文还是很详细的，大家可以琢磨一下。 CSDN整体二分刚接触的时候更容易懵上懵…这篇文章已经尽力了。 博客园这篇文章把二者放在一起谈，大家学完后可以看一看做个比较。 bitset 博客园bitset也算半个黑科技了吧…这里介绍了简单用法。 DP 博客园来自stdcall的四边形不等式讲解~ 博客园斜率优化初探，图文都好评~ CSDN（斜率优化前置？）单调队列优化也是很常用的技巧，经典的背包问题就可以用到这种优化QwQ。 一些奇妙的/基本的技巧/结论/方法 平面图边数极其稀疏，若点数为n,则边数不超过3n-6条（平面图中边不能交叉）。因此提到平面图的问题或许复杂度会跟边数相关。 题目若说字符串随机那么大家可以放心暴力，字符串随即情况下暴力有可能吊打std。当然不是推荐大家不学习正解 一颗随机生成的树树高期望为log级别，这种情况下一些O(树高相关)的暴力算法会有着优秀表现。 尽量不要用完整的小写单词当作变量。有时候评测环境和本地测试环境不同，本地过编译提交后却因关键字冲突而CE的情况比比皆是。 不用万能头的情况下，如果使用memset函数，一定要加上头文件，忘了加本地是可以过编译的但一般交上去后是不行的。我也忘了为什么 memset、字符串的加减都是线性复杂度，不要以为做n次字符串加减或memset的复杂度是O（n）的，实际上是O（n*数组长度（字符串长度））的。 网络流因为涉及到反向边，建边下标请从偶数开始。 树状数组和线段树理论上复杂度相同，但树状数组常数吊打线段树。而区间最值树状数组虽然复杂度上要多一个log，但是由于小常数，所以大概在n&lt;=1e5的范围内要比线段树跑的还快一些。 分块常数略大，莫队常数倒是很小。另外如果想要自己的分块更快的话，请手推最优块大小的式子，或者选择自造大样例，根据程序运行速度调整分块大小（同理模拟退火的玄学调参）。 （updating…）","raw":"---\ntitle: 教程合集\ntop: 9999\ntags: \n- OI\ncategories: \n- 学习笔记\n---\n\n~~不知道到底应该是“辑”还是“集”~~\n\n以下按照个人学习经历，会推荐一些好的博文供大家学习借鉴。~~当然如果大家觉得我写更好那就太棒啦QwQ。~~ ~~欸可是你现在什么都没写啊QAQ。~~\n\n### 数据结构\n\n#### 线段树\n\n- [CSDN](https://blog.csdn.net/zearot/article/details/48299459)\n个人认为网络上关于线段树讲的最好的没有之一。其中还包括了ZKW线段树与主席树的讲解，绝对良心QwQ。~~虽然CSDN是真的恶心。~~\n- [博客园](https://www.cnblogs.com/TheRoadToTheGold/p/6254255.html)\n没有上一篇全面，但内容对新手很友好。~~重要的是博客园界面显然比CSDN好太多。~~\n\n#### 树状数组\n\n- [博客园](http://www.cnblogs.com/RabbitHu/p/BIT.html)\n胡学姐所有博客都很良心啊QwQ！这一篇适合有树状数组基础的同学阅读，简单明快。\n- [CSDN](https://blog.csdn.net/bestsort/article/details/80796531)\n~~又是万恶的CSDN~~相较于上一篇更加详细，更适合小白阅读。不过如果已经比较熟练了看起来就觉得有些过于详细。\n\n#### 分块\n\n- [hzwer](http://hzwer.com/8053.html)\n关于分块就无脑添加黄学长的链接了。分块入门1-9已成经典QwQ。\n\n~~另外如果对分块感兴趣的同学可以刷一刷Ynoi~~\n\n#### 平衡树\n\n- [博客园](https://www.cnblogs.com/victorique/p/8478866.html)\n关于Splay的不错讲解。不过伸展树这东西建议大家一定要结合代码画图理解。\n\n#### Link-Cut Tree\n\n- [博客园](http://www.cnblogs.com/flashhu/p/8324551.html)\n个人心目中动态树讲的最好的博文，并且内附LCT应用讲解的链接，十分良心。\n\n#### 树链剖分\n\n- [博客园](https://www.cnblogs.com/ivanovcraft/p/9019090.html)\n树剖大全啦可以算是。\n\n### 字符串\n\n#### KMP\n\n- [NOI2014动物园](https://www.luogu.org/problemnew/show/P2375)\n认真的，KMP的核心思想这道题和它的题解阐述的非常棒。\n\n- [博客园](https://www.cnblogs.com/en-heng/p/5091365.html)\n也同样很精炼，适合初学者认真研读思考。\n\n~~其实关于KMP我建议各位去找Peter_Matthew要PPT~~\n\n#### Trie树\n\n- [博客园](https://www.cnblogs.com/TheRoadToTheGold/p/6290732.html)\n非常详细了...虽然只是一个小知识点。\n\n#### AC自动机\n\n- [博客园](https://www.cnblogs.com/cmmdc/p/7337611.html)\nAC自动机也需要大量画图和思考才能方便理解。\n\n#### 后缀数组\n\n- [博客园](https://www.cnblogs.com/zwfymqz/p/8413523.html)\nattack讲的后缀数组已经非常良心了，不过这东西本身会有些难懂，个人也要多琢磨琢磨。\n\n- [百度文库](https://wenku.baidu.com/view/228caa45b307e87101f696a8.html)\n既然提到后缀数组就不能少了罗穗骞的论文。\n\n#### 后缀自动机\n\n- [Luogu](https://www.luogu.org/blog/Kesdiael3/hou-zhui-zi-dong-ji-yang-xie)\n很美妙的算法，应该是字符串算法中最难理解透彻的了。这篇文章较之同类讲解更适合入门与拓展。\n\n### 数学相关\n\n#### 计数问题\n\n- [Luogu](https://www.luogu.org/blog/chengni5673/dang-xiao-qiu-yu-shang-he-zi)\n组合数学经典讲解，几乎涵盖了组合数学所有的基础内容，墙裂推荐！\n\n- [Luogu](https://www.luogu.org/blog/KingSann/chu-tan-rong-chi-yuan-li)\n关于容斥很不错的讲解，不过数学公式略多初学者可能看着会有些头疼QwQ。\n\n#### 数论\n\n- [博客园](https://www.cnblogs.com/mrclr/p/9380300.html)\n关于exgcd的基础讲解，式子推的很工整，不过内容较少。\n\n- [CSDN](https://blog.csdn.net/zhjchengfeng5/article/details/7786595)\n关于exgcd较之上一篇讲的更加详细。\n\n- [博客园](https://www.cnblogs.com/chy-2003/p/9656801.html)\n关于逆元十分详细并且清楚的讲解。\n\n- [博客园](https://www.cnblogs.com/jason2003/p/9761296.html)\n难得对欧拉筛有证明的文章...\n\n- [博客园](https://www.cnblogs.com/peng-ym/p/8647856.html)\n莫比乌斯反演的讲解要力推pengym！包括整除分块、杜教筛也可以看他的博客。\n\n- [博客园](https://www.cnblogs.com/Miracevin/p/9254795.html)\ncrt和excrt本身就是数论中相对较难推演的算法，建议大家结合博文自行演算几遍。\n\n- [博客园](https://www.cnblogs.com/sdzwyq/p/9900650.html)\nbsgs与exbsgs，但没有提及正确性。要对简单证明感兴趣可以 [戳这里](https://blog.csdn.net/sodacoco/article/details/81515576)。\n\n#### 线性代数\n\n- [博客园](https://www.cnblogs.com/cmmdc/p/6936196.html)\n矩阵乘法与矩阵快速幂入门好文。\n\n- [menci](https://oi.men.ci/linear-basis-notes/)\n线性基中蕴含了线代的思想所以我就把menci的线性基讲解放在这里了...说实话menci讲得有一点点过于正式，或许不太好懂？不过的确是教科书般的模范好文。~~在此无耻自荐Micardi的讲解~~ \n\n- [github](https://wa-automaton.github.io/2019/03/06/矩阵树定理总结/)\n高一神犇XD同学关于行列式、矩阵树的讲解！个人觉得还是很不错的QwQ。不过因为这部分知识本身就不好理解，建议大家也要多多自行演算。\n\n- [博客园](https://www.cnblogs.com/zj75211/p/8039443.html)\n关于行列式/矩阵树的另一份不错讲解，十分详细，适合入门。\n\n~~关于高斯消元我建议大家看看luogu题解就差不多了~~\n\n#### 图论\n\n- [博客园](https://www.cnblogs.com/shadowland/p/5872257.html)\ntarjan的好讲解。个人觉得tarjan算法重在画图理解，理解了实现起来十分简单。\n\n- [博客园](https://www.cnblogs.com/shenben/p/5573788.html)\n二分图与匈牙利的良心讲解，介绍了很多好题与基础模型、定理。\n\n- [Luogu](https://www.luogu.org/blog/user9012/post-2-sat-lve-xie)\n2-sat感觉要成冷门算法了...不过通过这篇博文略知一二也是不错的QwQ。\n\n- [博客园](https://www.cnblogs.com/rmy020718/p/9546071.html)\n玄学网络流玄学讲解QwQ通过这篇由浅入深的博客，感性理解Dinic吧！\n\n- [博客园](https://www.cnblogs.com/rmy020718/p/9548758.html)\n费用流好文嗷。\n\n- [博客园](https://www.cnblogs.com/victorique/p/8560656.html)\n网络流难在建模，这篇文章给出了很多经典例题供大家学习参考。\n\n#### 概率期望\n\n- [博客园](https://www.cnblogs.com/Paul-Guderian/p/7624039.html)\n概率期望网上相关讲解很少，建议大家最好从纯数学角度去打好基础，多做题目。而大米饼这篇博客大概是我见过关于期望概率dp讲解最详细的文章了。\n\n#### 多项式相关\n\n- [博客园](https://www.cnblogs.com/RabbitHu/p/FFT.html)\n真的是再通俗易懂不过的fft讲解了。~~同时会了FFT之后NTT就跟背板子无异了。~~\n\n#### 博弈论\n\n- [CSDN](https://blog.csdn.net/wang3312362136/article/details/79303794)\n史上最全面的博弈论讲解了大概。~~不过这东西考了大家估计也都不会毕竟SG函数是个太玄学的东西了。~~\n\n### 其它\n\n#### 莫队\n\n- [博客园](https://www.cnblogs.com/Paul-Guderian/p/6933799.html)\n美妙的指针在路径上跳来跳去，祝您达到顶尖~\n\n#### cdq分治&&整体二分\n\n- [博客园](http://www.cnblogs.com/mlystdcall/p/6219421.html)\ncdq分治这东西初次接触可能不好理解，不过stdcall这篇博文还是很详细的，大家可以琢磨一下。\n\n- [CSDN](https://blog.csdn.net/wu_tongtong/article/details/78823783)\n整体二分刚接触的时候更容易懵上懵...这篇文章已经尽力了。\n\n- [博客园](https://www.cnblogs.com/fenghaoran/p/7436593.html)\n这篇文章把二者放在一起谈，大家学完后可以看一看做个比较。\n\n#### bitset\n\n- [博客园](https://www.cnblogs.com/RabbitHu/p/bitset.html)\nbitset也算半个黑科技了吧...这里介绍了简单用法。\n\n#### DP\n\n- [博客园](https://www.cnblogs.com/mlystdcall/p/6525962.html)\n来自stdcall的四边形不等式讲解~\n\n- [博客园](https://www.cnblogs.com/orzzz/p/7885971.html)\n斜率优化初探，图文都好评~\n\n- [CSDN](https://blog.csdn.net/A1847225889/article/details/77777009)\n（斜率优化前置？）单调队列优化也是很常用的技巧，经典的背包问题就可以用到这种优化QwQ。\n\n### 一些奇妙的/基本的技巧/结论/方法\n\n- 平面图边数极其稀疏，若点数为n,则边数不超过3n-6条（平面图中边不能交叉）。因此提到平面图的问题或许复杂度会跟边数相关。\n- 题目若说**字符串随机**那么大家可以放心暴力，字符串随即情况下暴力有可能吊打std。~~当然不是推荐大家不学习正解~~\n- 一颗随机生成的树树高期望为log级别，这种情况下一些O(树高相关)的暴力算法会有着优秀表现。\n- **尽量不要用完整的小写单词当作变量。**有时候评测环境和本地测试环境不同，本地过编译提交后却因关键字冲突而CE的情况比比皆是。\n- 不用万能头的情况下，如果使用memset函数，一定要加上头文件<cstring>，忘了加本地是可以过编译的但一般交上去后是不行的。~~我也忘了为什么~~\n- memset、字符串的加减都是**线性复杂度**，不要以为做n次字符串加减或memset的复杂度是O（n）的，实际上是O（n*数组长度（字符串长度））的。\n- 网络流因为涉及到反向边，建边下标请从偶数开始。\n- 树状数组和线段树理论上复杂度相同，但树状数组常数吊打线段树。而区间最值树状数组虽然复杂度上要多一个log，但是由于小常数，所以大概在n<=1e5的范围内要比线段树跑的还快一些。\n- 分块常数略大，莫队常数倒是很小。另外如果想要自己的分块更快的话，请手推最优块大小的式子，或者选择自造大样例，根据程序运行速度调整分块大小（同理模拟退火的玄学调参）。\n\n（updating...）","content":"<p><del>不知道到底应该是“辑”还是“集”</del></p>\n<p>以下按照个人学习经历，会推荐一些好的博文供大家学习借鉴。<del>当然如果大家觉得我写更好那就太棒啦QwQ。</del> <del>欸可是你现在什么都没写啊QAQ。</del></p>\n<h3 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h3><h4 id=\"线段树\"><a href=\"#线段树\" class=\"headerlink\" title=\"线段树\"></a>线段树</h4><ul>\n<li><a href=\"https://blog.csdn.net/zearot/article/details/48299459\" target=\"_blank\" rel=\"noopener\">CSDN</a><br>个人认为网络上关于线段树讲的最好的没有之一。其中还包括了ZKW线段树与主席树的讲解，绝对良心QwQ。<del>虽然CSDN是真的恶心。</del></li>\n<li><a href=\"https://www.cnblogs.com/TheRoadToTheGold/p/6254255.html\" target=\"_blank\" rel=\"noopener\">博客园</a><br>没有上一篇全面，但内容对新手很友好。<del>重要的是博客园界面显然比CSDN好太多。</del></li>\n</ul>\n<h4 id=\"树状数组\"><a href=\"#树状数组\" class=\"headerlink\" title=\"树状数组\"></a>树状数组</h4><ul>\n<li><a href=\"http://www.cnblogs.com/RabbitHu/p/BIT.html\" target=\"_blank\" rel=\"noopener\">博客园</a><br>胡学姐所有博客都很良心啊QwQ！这一篇适合有树状数组基础的同学阅读，简单明快。</li>\n<li><a href=\"https://blog.csdn.net/bestsort/article/details/80796531\" target=\"_blank\" rel=\"noopener\">CSDN</a><br><del>又是万恶的CSDN</del>相较于上一篇更加详细，更适合小白阅读。不过如果已经比较熟练了看起来就觉得有些过于详细。</li>\n</ul>\n<h4 id=\"分块\"><a href=\"#分块\" class=\"headerlink\" title=\"分块\"></a>分块</h4><ul>\n<li><a href=\"http://hzwer.com/8053.html\" target=\"_blank\" rel=\"noopener\">hzwer</a><br>关于分块就无脑添加黄学长的链接了。分块入门1-9已成经典QwQ。</li>\n</ul>\n<p><del>另外如果对分块感兴趣的同学可以刷一刷Ynoi</del></p>\n<h4 id=\"平衡树\"><a href=\"#平衡树\" class=\"headerlink\" title=\"平衡树\"></a>平衡树</h4><ul>\n<li><a href=\"https://www.cnblogs.com/victorique/p/8478866.html\" target=\"_blank\" rel=\"noopener\">博客园</a><br>关于Splay的不错讲解。不过伸展树这东西建议大家一定要结合代码画图理解。</li>\n</ul>\n<h4 id=\"Link-Cut-Tree\"><a href=\"#Link-Cut-Tree\" class=\"headerlink\" title=\"Link-Cut Tree\"></a>Link-Cut Tree</h4><ul>\n<li><a href=\"http://www.cnblogs.com/flashhu/p/8324551.html\" target=\"_blank\" rel=\"noopener\">博客园</a><br>个人心目中动态树讲的最好的博文，并且内附LCT应用讲解的链接，十分良心。</li>\n</ul>\n<h4 id=\"树链剖分\"><a href=\"#树链剖分\" class=\"headerlink\" title=\"树链剖分\"></a>树链剖分</h4><ul>\n<li><a href=\"https://www.cnblogs.com/ivanovcraft/p/9019090.html\" target=\"_blank\" rel=\"noopener\">博客园</a><br>树剖大全啦可以算是。</li>\n</ul>\n<h3 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h3><h4 id=\"KMP\"><a href=\"#KMP\" class=\"headerlink\" title=\"KMP\"></a>KMP</h4><ul>\n<li><p><a href=\"https://www.luogu.org/problemnew/show/P2375\" target=\"_blank\" rel=\"noopener\">NOI2014动物园</a><br>认真的，KMP的核心思想这道题和它的题解阐述的非常棒。</p>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/en-heng/p/5091365.html\" target=\"_blank\" rel=\"noopener\">博客园</a><br>也同样很精炼，适合初学者认真研读思考。</p>\n</li>\n</ul>\n<p><del>其实关于KMP我建议各位去找Peter_Matthew要PPT</del></p>\n<h4 id=\"Trie树\"><a href=\"#Trie树\" class=\"headerlink\" title=\"Trie树\"></a>Trie树</h4><ul>\n<li><a href=\"https://www.cnblogs.com/TheRoadToTheGold/p/6290732.html\" target=\"_blank\" rel=\"noopener\">博客园</a><br>非常详细了…虽然只是一个小知识点。</li>\n</ul>\n<h4 id=\"AC自动机\"><a href=\"#AC自动机\" class=\"headerlink\" title=\"AC自动机\"></a>AC自动机</h4><ul>\n<li><a href=\"https://www.cnblogs.com/cmmdc/p/7337611.html\" target=\"_blank\" rel=\"noopener\">博客园</a><br>AC自动机也需要大量画图和思考才能方便理解。</li>\n</ul>\n<h4 id=\"后缀数组\"><a href=\"#后缀数组\" class=\"headerlink\" title=\"后缀数组\"></a>后缀数组</h4><ul>\n<li><p><a href=\"https://www.cnblogs.com/zwfymqz/p/8413523.html\" target=\"_blank\" rel=\"noopener\">博客园</a><br>attack讲的后缀数组已经非常良心了，不过这东西本身会有些难懂，个人也要多琢磨琢磨。</p>\n</li>\n<li><p><a href=\"https://wenku.baidu.com/view/228caa45b307e87101f696a8.html\" target=\"_blank\" rel=\"noopener\">百度文库</a><br>既然提到后缀数组就不能少了罗穗骞的论文。</p>\n</li>\n</ul>\n<h4 id=\"后缀自动机\"><a href=\"#后缀自动机\" class=\"headerlink\" title=\"后缀自动机\"></a>后缀自动机</h4><ul>\n<li><a href=\"https://www.luogu.org/blog/Kesdiael3/hou-zhui-zi-dong-ji-yang-xie\" target=\"_blank\" rel=\"noopener\">Luogu</a><br>很美妙的算法，应该是字符串算法中最难理解透彻的了。这篇文章较之同类讲解更适合入门与拓展。</li>\n</ul>\n<h3 id=\"数学相关\"><a href=\"#数学相关\" class=\"headerlink\" title=\"数学相关\"></a>数学相关</h3><h4 id=\"计数问题\"><a href=\"#计数问题\" class=\"headerlink\" title=\"计数问题\"></a>计数问题</h4><ul>\n<li><p><a href=\"https://www.luogu.org/blog/chengni5673/dang-xiao-qiu-yu-shang-he-zi\" target=\"_blank\" rel=\"noopener\">Luogu</a><br>组合数学经典讲解，几乎涵盖了组合数学所有的基础内容，墙裂推荐！</p>\n</li>\n<li><p><a href=\"https://www.luogu.org/blog/KingSann/chu-tan-rong-chi-yuan-li\" target=\"_blank\" rel=\"noopener\">Luogu</a><br>关于容斥很不错的讲解，不过数学公式略多初学者可能看着会有些头疼QwQ。</p>\n</li>\n</ul>\n<h4 id=\"数论\"><a href=\"#数论\" class=\"headerlink\" title=\"数论\"></a>数论</h4><ul>\n<li><p><a href=\"https://www.cnblogs.com/mrclr/p/9380300.html\" target=\"_blank\" rel=\"noopener\">博客园</a><br>关于exgcd的基础讲解，式子推的很工整，不过内容较少。</p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/zhjchengfeng5/article/details/7786595\" target=\"_blank\" rel=\"noopener\">CSDN</a><br>关于exgcd较之上一篇讲的更加详细。</p>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/chy-2003/p/9656801.html\" target=\"_blank\" rel=\"noopener\">博客园</a><br>关于逆元十分详细并且清楚的讲解。</p>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/jason2003/p/9761296.html\" target=\"_blank\" rel=\"noopener\">博客园</a><br>难得对欧拉筛有证明的文章…</p>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/peng-ym/p/8647856.html\" target=\"_blank\" rel=\"noopener\">博客园</a><br>莫比乌斯反演的讲解要力推pengym！包括整除分块、杜教筛也可以看他的博客。</p>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/Miracevin/p/9254795.html\" target=\"_blank\" rel=\"noopener\">博客园</a><br>crt和excrt本身就是数论中相对较难推演的算法，建议大家结合博文自行演算几遍。</p>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/sdzwyq/p/9900650.html\" target=\"_blank\" rel=\"noopener\">博客园</a><br>bsgs与exbsgs，但没有提及正确性。要对简单证明感兴趣可以 <a href=\"https://blog.csdn.net/sodacoco/article/details/81515576\" target=\"_blank\" rel=\"noopener\">戳这里</a>。</p>\n</li>\n</ul>\n<h4 id=\"线性代数\"><a href=\"#线性代数\" class=\"headerlink\" title=\"线性代数\"></a>线性代数</h4><ul>\n<li><p><a href=\"https://www.cnblogs.com/cmmdc/p/6936196.html\" target=\"_blank\" rel=\"noopener\">博客园</a><br>矩阵乘法与矩阵快速幂入门好文。</p>\n</li>\n<li><p><a href=\"https://oi.men.ci/linear-basis-notes/\" target=\"_blank\" rel=\"noopener\">menci</a><br>线性基中蕴含了线代的思想所以我就把menci的线性基讲解放在这里了…说实话menci讲得有一点点过于正式，或许不太好懂？不过的确是教科书般的模范好文。<del>在此无耻自荐Micardi的讲解</del> </p>\n</li>\n<li><p><a href=\"https://wa-automaton.github.io/2019/03/06/矩阵树定理总结/\" target=\"_blank\" rel=\"noopener\">github</a><br>高一神犇XD同学关于行列式、矩阵树的讲解！个人觉得还是很不错的QwQ。不过因为这部分知识本身就不好理解，建议大家也要多多自行演算。</p>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/zj75211/p/8039443.html\" target=\"_blank\" rel=\"noopener\">博客园</a><br>关于行列式/矩阵树的另一份不错讲解，十分详细，适合入门。</p>\n</li>\n</ul>\n<p><del>关于高斯消元我建议大家看看luogu题解就差不多了</del></p>\n<h4 id=\"图论\"><a href=\"#图论\" class=\"headerlink\" title=\"图论\"></a>图论</h4><ul>\n<li><p><a href=\"https://www.cnblogs.com/shadowland/p/5872257.html\" target=\"_blank\" rel=\"noopener\">博客园</a><br>tarjan的好讲解。个人觉得tarjan算法重在画图理解，理解了实现起来十分简单。</p>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/shenben/p/5573788.html\" target=\"_blank\" rel=\"noopener\">博客园</a><br>二分图与匈牙利的良心讲解，介绍了很多好题与基础模型、定理。</p>\n</li>\n<li><p><a href=\"https://www.luogu.org/blog/user9012/post-2-sat-lve-xie\" target=\"_blank\" rel=\"noopener\">Luogu</a><br>2-sat感觉要成冷门算法了…不过通过这篇博文略知一二也是不错的QwQ。</p>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/rmy020718/p/9546071.html\" target=\"_blank\" rel=\"noopener\">博客园</a><br>玄学网络流玄学讲解QwQ通过这篇由浅入深的博客，感性理解Dinic吧！</p>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/rmy020718/p/9548758.html\" target=\"_blank\" rel=\"noopener\">博客园</a><br>费用流好文嗷。</p>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/victorique/p/8560656.html\" target=\"_blank\" rel=\"noopener\">博客园</a><br>网络流难在建模，这篇文章给出了很多经典例题供大家学习参考。</p>\n</li>\n</ul>\n<h4 id=\"概率期望\"><a href=\"#概率期望\" class=\"headerlink\" title=\"概率期望\"></a>概率期望</h4><ul>\n<li><a href=\"https://www.cnblogs.com/Paul-Guderian/p/7624039.html\" target=\"_blank\" rel=\"noopener\">博客园</a><br>概率期望网上相关讲解很少，建议大家最好从纯数学角度去打好基础，多做题目。而大米饼这篇博客大概是我见过关于期望概率dp讲解最详细的文章了。</li>\n</ul>\n<h4 id=\"多项式相关\"><a href=\"#多项式相关\" class=\"headerlink\" title=\"多项式相关\"></a>多项式相关</h4><ul>\n<li><a href=\"https://www.cnblogs.com/RabbitHu/p/FFT.html\" target=\"_blank\" rel=\"noopener\">博客园</a><br>真的是再通俗易懂不过的fft讲解了。<del>同时会了FFT之后NTT就跟背板子无异了。</del></li>\n</ul>\n<h4 id=\"博弈论\"><a href=\"#博弈论\" class=\"headerlink\" title=\"博弈论\"></a>博弈论</h4><ul>\n<li><a href=\"https://blog.csdn.net/wang3312362136/article/details/79303794\" target=\"_blank\" rel=\"noopener\">CSDN</a><br>史上最全面的博弈论讲解了大概。<del>不过这东西考了大家估计也都不会毕竟SG函数是个太玄学的东西了。</del></li>\n</ul>\n<h3 id=\"其它\"><a href=\"#其它\" class=\"headerlink\" title=\"其它\"></a>其它</h3><h4 id=\"莫队\"><a href=\"#莫队\" class=\"headerlink\" title=\"莫队\"></a>莫队</h4><ul>\n<li><a href=\"https://www.cnblogs.com/Paul-Guderian/p/6933799.html\" target=\"_blank\" rel=\"noopener\">博客园</a><br>美妙的指针在路径上跳来跳去，祝您达到顶尖~</li>\n</ul>\n<h4 id=\"cdq分治-amp-amp-整体二分\"><a href=\"#cdq分治-amp-amp-整体二分\" class=\"headerlink\" title=\"cdq分治&amp;&amp;整体二分\"></a>cdq分治&amp;&amp;整体二分</h4><ul>\n<li><p><a href=\"http://www.cnblogs.com/mlystdcall/p/6219421.html\" target=\"_blank\" rel=\"noopener\">博客园</a><br>cdq分治这东西初次接触可能不好理解，不过stdcall这篇博文还是很详细的，大家可以琢磨一下。</p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/wu_tongtong/article/details/78823783\" target=\"_blank\" rel=\"noopener\">CSDN</a><br>整体二分刚接触的时候更容易懵上懵…这篇文章已经尽力了。</p>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/fenghaoran/p/7436593.html\" target=\"_blank\" rel=\"noopener\">博客园</a><br>这篇文章把二者放在一起谈，大家学完后可以看一看做个比较。</p>\n</li>\n</ul>\n<h4 id=\"bitset\"><a href=\"#bitset\" class=\"headerlink\" title=\"bitset\"></a>bitset</h4><ul>\n<li><a href=\"https://www.cnblogs.com/RabbitHu/p/bitset.html\" target=\"_blank\" rel=\"noopener\">博客园</a><br>bitset也算半个黑科技了吧…这里介绍了简单用法。</li>\n</ul>\n<h4 id=\"DP\"><a href=\"#DP\" class=\"headerlink\" title=\"DP\"></a>DP</h4><ul>\n<li><p><a href=\"https://www.cnblogs.com/mlystdcall/p/6525962.html\" target=\"_blank\" rel=\"noopener\">博客园</a><br>来自stdcall的四边形不等式讲解~</p>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/orzzz/p/7885971.html\" target=\"_blank\" rel=\"noopener\">博客园</a><br>斜率优化初探，图文都好评~</p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/A1847225889/article/details/77777009\" target=\"_blank\" rel=\"noopener\">CSDN</a><br>（斜率优化前置？）单调队列优化也是很常用的技巧，经典的背包问题就可以用到这种优化QwQ。</p>\n</li>\n</ul>\n<h3 id=\"一些奇妙的-基本的技巧-结论-方法\"><a href=\"#一些奇妙的-基本的技巧-结论-方法\" class=\"headerlink\" title=\"一些奇妙的/基本的技巧/结论/方法\"></a>一些奇妙的/基本的技巧/结论/方法</h3><ul>\n<li>平面图边数极其稀疏，若点数为n,则边数不超过3n-6条（平面图中边不能交叉）。因此提到平面图的问题或许复杂度会跟边数相关。</li>\n<li>题目若说<strong>字符串随机</strong>那么大家可以放心暴力，字符串随即情况下暴力有可能吊打std。<del>当然不是推荐大家不学习正解</del></li>\n<li>一颗随机生成的树树高期望为log级别，这种情况下一些O(树高相关)的暴力算法会有着优秀表现。</li>\n<li><strong>尽量不要用完整的小写单词当作变量。</strong>有时候评测环境和本地测试环境不同，本地过编译提交后却因关键字冲突而CE的情况比比皆是。</li>\n<li>不用万能头的情况下，如果使用memset函数，一定要加上头文件<cstring>，忘了加本地是可以过编译的但一般交上去后是不行的。<del>我也忘了为什么</del></cstring></li>\n<li>memset、字符串的加减都是<strong>线性复杂度</strong>，不要以为做n次字符串加减或memset的复杂度是O（n）的，实际上是O（n*数组长度（字符串长度））的。</li>\n<li>网络流因为涉及到反向边，建边下标请从偶数开始。</li>\n<li>树状数组和线段树理论上复杂度相同，但树状数组常数吊打线段树。而区间最值树状数组虽然复杂度上要多一个log，但是由于小常数，所以大概在n&lt;=1e5的范围内要比线段树跑的还快一些。</li>\n<li>分块常数略大，莫队常数倒是很小。另外如果想要自己的分块更快的话，请手推最优块大小的式子，或者选择自造大样例，根据程序运行速度调整分块大小（同理模拟退火的玄学调参）。</li>\n</ul>\n<p>（updating…）</p>\n","slug":"教程合集","updated":"2019-04-08T09:46:26.686Z","link":"","permalink":"https://micardi.github.io/2019/04/08/教程合集/","excerpt":"","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://micardi.github.io/categories/学习笔记/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://micardi.github.io/tags/OI/"}]},{"title":"Goodbye,OI!","date":"2019-04-08T01:26:49.246Z","path":"2019/04/08/退役随笔/","text":"To Do List 加入信竞 √ Accomplish 拿到省一 √ Accomplish 去冬令营 √ Accomplish 进入省队… × Failed. My Trip in OI2018.5从开昕那里借到了紫书！艰难地啃完了基本语法…… 2018.6给go爷打了一通电话！意外地成功加入信息竞赛！ 2018.7在去诸暨的火车上达哥教会了我结构体。满心欢喜以为自己学会了什么不得了的东西。达哥：恭喜你已经入门了！我：？？？才是入门吗…… 海亮真漂亮啊QwQ矿主家孩子的学校。 与盒子先生一起看了世界杯决赛！支持的球队决赛从没赢过QAQ 被小学生初中生吊打了一段时间…然后发现我可以吊打他们了QwQ 2018.8咕掉了拓展训练…现在想想也没什么可惜的。呆在机房最快乐！虽然确确实实被吊打了一个星期QAQ。 期间还撞上了高一的军训文艺汇演……没看多久就被抓回去打代码了233333333。 2018.9停掉了晚自习去机房考试…跟大家慢慢熟起来啦QwQ，也不再天天垫底被吊打…不过依旧很为两个月后的NOIp紧张。 运动会皓哥主笔、大家谋划为我写的加油稿，我能暖一辈子(ಥ _ ಥ)。 2018.10月考爆炸了…从来没这么垃圾过。跟家长一番争吵后还是继续学了下去。索性直接停了课备战省赛。 搬到四楼机房呆了一阵，很快乐的一段时光。 2018.11嘴上说着省二退役，心里却对省队怀着憧憬。于是自己对NOIp成绩的要求就不只是简简单单过线了。 Day1大起大落…差点死于T1T2。Day2下来本以为能有120+，结果发现T1写挂12分，T2… ×3-&gt;×6÷2，取模意义下直接全挂…不过现在看来，无伤大雅了。 皓哥和达哥要退役了，曾经对我OI学习帮助最大的两位神仙啊…第一次这么真切地感受到了竞赛的残酷和无常。很难过，却不知道该说些什么。 很多人的命运都是未知…但有些回忆已是永恒。 2018.12文化课补得及其开心…假的！还是OI才能带给我快乐啊QAQ！ 去参加了市赛，抱大腿拿了个团队第二。 2019.1决定了继续走下去,于是疯狂补习省选知识点。 去到了Winter Camp，虽然天天掉线却觉得受益匪浅——最重要的是非常开心啊QwQ。 2019.2春节七天乐，之后就开始欢快的紧张刺激的省选备战。 在总校苟了七八天？zzy太神啦lch太神啦xd太神啦syt太神啦…都好神仙啊…才学半年啊好恐怖啊QAQ，敝校AU就看各位神仙啦QwQ 下了两天雪，可惜身边全是男生啊QAQ这么棒的意境…不过居然也觉得有些浪漫？ 2019.3月初得知HA今年联考，省选日期提前了两个星期，心态有点炸…状态迷失的伏笔。 要出去集训啦…有种自己时日不多了的感觉QwQ。 出去前先给尚宝、卢神和XD过了个集体生日。 目标芜湖，先到南京，晚上逛了逛夫子庙，第二天fancy学姐带我们在南大转了一圈QwQ…实名表白仙林校区！ 之后就是安师大附中的十二日集训啦…见识到了许多神仙般的人物幸好没有我省的，深感自己差得还远…于是自闭并且到现在都没完全恢复过来QAQ。 临走前go爷又是一顿请，还怂恿未成年人喝酒QAQ 2019.4十二省联考的月份。 Day1看错题-&gt;心态爆炸，Day2没什么心思了结果还挂分。退役了。不想说太多。 结束了。 AFO退役了。出乎自己意料的平静。唯一还耿耿于怀的是郑外的全军覆没。这两天经常会想，如果自己当初不看错题面，如果开昕哈希不出锅，如果孙神Day2放平心态，如果尚宝没有多测不清空，如果王子骏NOIp再多哪怕10分…我们或许都可以继续走下去吧，或许就不会落得这样略显悲凉的结局了吧。这样的假设只能带给自己心里安慰，并无任何意义——或许连安慰都没法带来。自己再清楚不过了，考场上所有意外情况的发生，究其原因还是因为自己的弱小。竞赛中，菜是原罪——无论是硬实力上的不足，还是心态上的缺失，失败就是失败，技不如人罢了。虽然全员翻车太让人意外，也似乎太过残酷——但这就是竞赛吧，这就是生活吧。概率哪怕再小的事情一旦发生了，那就是丝毫不值得惊讶与惋惜的现实了。希望能给学弟学妹们留一个教训，也希望郑外OI能挫而愈勇，卷土重来。遗憾已经留了，说什么都挽回不了。我们唯一能做的，就是在未来更加小心地走好每一步吧。 前路会与过往不同，但精彩纷呈。 与诸君共勉。","raw":"---\ntitle: Goodbye,OI!\ntop: 10000\ntags: \n- OI\ncategories: \n- 随笔\n---\n\n### To Do List\n\n1. 加入信竞  √ Accomplish\n2. 拿到省一  √ Accomplish\n3. 去冬令营  √ Accomplish\n4. 进入省队...\n\n× Failed.\n\n### My Trip in OI\n\n#### 2018.5 \n\n从开昕那里借到了紫书！艰难地啃完了基本语法......\n![循环嵌套当初搞死我了QAQ](http://i1.bvimg.com/683055/2aa5ffec26b06de8.jpg)\n\n#### 2018.6 \n\n给go爷打了一通电话！意外地成功加入信息竞赛！\n\n#### 2018.7 \n\n在去诸暨的火车上达哥教会了我结构体。满心欢喜以为自己学会了什么不得了的东西。\n达哥：恭喜你已经入门了！\n我：？？？才是入门吗......\n\n海亮真漂亮啊QwQ矿主家孩子的学校。\n![调的很失真QAQ不过很喜欢QwQ暴雨将至](http://i1.bvimg.com/683055/8ead460edf1a524c.jpg)\n![天气很好！](http://i1.bvimg.com/683055/2a0045f516910932.jpg)\n![这真的不是度假村吗...](http://i1.bvimg.com/683055/02810fb903b9e316.jpg)\n![别人家的学校(╯‵□′)╯︵┻━┻](http://i1.bvimg.com/683055/55949698e1f7c9f2.jpg)\n\n与盒子先生一起看了世界杯决赛！支持的球队决赛从没赢过QAQ\n![Danbo和他的电脑](http://i1.bvimg.com/683055/f274b4d72b5464e3.jpg)\n\n被小学生初中生吊打了一段时间...然后发现我可以吊打他们了QwQ\n![当即兴奋地合影留念QwQ](http://i1.bvimg.com/683055/e5670b87ae116705.jpg)\n![坚持下去就有可能](http://i1.bvimg.com/683055/d3ebb52bff89fe0f.jpg)\n\n#### 2018.8\n\n咕掉了拓展训练...现在想想也没什么可惜的。呆在机房最快乐！虽然确确实实被吊打了一个星期QAQ。\n![外卖现场QwQ](http://i2.bvimg.com/683055/3f47f7de40243e91.jpg)\n\n期间还撞上了高一的军训文艺汇演......没看多久就被抓回去打代码了233333333。\n![QwQ](http://i1.bvimg.com/683055/9b6eb8b32b0114f5.jpg)\n![po一张洒脱的帅哥](http://i2.bvimg.com/683055/3acedc06bb37943e.jpg)\n\n#### 2018.9\n\n停掉了晚自习去机房考试...跟大家慢慢熟起来啦QwQ，也不再天天垫底被吊打...不过依旧很为两个月后的NOIp紧张。\n\n运动会皓哥主笔、大家谋划为我写的加油稿，我能暖一辈子(ಥ _ ಥ)。\n![真的很感动啊QAQ](http://i1.bvimg.com/683055/fefc2be0332c0388.jpg)\n\n#### 2018.10\n\n月考爆炸了...从来没这么垃圾过。跟家长一番争吵后还是继续学了下去。索性直接停了课备战省赛。\n\n搬到四楼机房呆了一阵，很快乐的一段时光。\n![想皓哥和尚宝了QAQ还有开心](http://i2.bvimg.com/683055/54900f505e155ccd.jpg)\n\n#### 2018.11\n\n嘴上说着省二退役，心里却对省队怀着憧憬。于是自己对NOIp成绩的要求就不只是简简单单过线了。\n\n![一点点紧张](http://i2.bvimg.com/683055/34473dc5d020088f.jpg)\n![CCF真的很严格QwQ](http://i2.bvimg.com/683055/eadba068df4f0372.jpg)\n![NOIp前最后一次机惨233](http://i2.bvimg.com/683055/0f2adc746e947908.jpg)\n\nDay1大起大落...差点死于T1T2。Day2下来本以为能有120+，结果发现T1写挂12分，T2...\n\n![智障Micardi在线傻逼QAQ](http://i2.bvimg.com/683055/c68b6089d455a505.png)\n\n×3->×6÷2，取模意义下直接全挂...不过现在看来，无伤大雅了。\n\n皓哥和达哥要退役了，曾经对我OI学习帮助最大的两位神仙啊...第一次这么真切地感受到了竞赛的残酷和无常。很难过，却不知道该说些什么。\n\n很多人的命运都是未知...但有些回忆已是永恒。\n\n![辣椒油同学！](http://i1.bvimg.com/683055/c1d34540a62bc01a.jpg)\n![省赛前清理机房...伤感](http://i1.bvimg.com/683055/a9c87d88fe7d7f25.jpg)\n![省赛后聚餐！两位神仙嗷QwQ](http://i1.bvimg.com/683055/63dcd947a53e8d30.jpg)\n![love u all!](http://i1.bvimg.com/683055/57c34b433f5e9fb4.jpg)\n\n#### 2018.12\n\n文化课补得及其开心...假的！还是OI才能带给我快乐啊QAQ！\n\n去参加了市赛，抱大腿拿了个团队第二。\n\n![方舟tql！！！](http://i2.bvimg.com/683055/fb0252370824ebbf.jpg)\n\n#### 2019.1\n\n决定了继续走下去,于是疯狂补习省选知识点。\n\n去到了Winter Camp，虽然天天掉线却觉得受益匪浅——最重要的是非常开心啊QwQ。\n\n![签到板上看到了许多神仙的名字](http://i2.bvimg.com/683055/3f49952e8350411d.jpg)\n![为松松和他的小黄鸭打call！](http://i2.bvimg.com/683055/0a8c2deec978004d.jpg)\n![某人说有入藏的感觉？](http://i2.bvimg.com/683055/bd580a300f5a94ea.jpg)\n![好基友QwQ](http://i2.bvimg.com/683055/8e66b8533dd982e4.jpg)\n![HA省夜会！](http://i2.bvimg.com/683055/b32602d887ff72e6.jpg)\n![喜欢夜深人静码代码的感觉嗷](http://i1.bvimg.com/683055/6bfa4abe75394b28.jpg)\n\n#### 2019.2\n\n春节七天乐，之后就开始~~欢快的~~紧张刺激的省选备战。\n\n在总校苟了七八天？zzy太神啦lch太神啦xd太神啦syt太神啦...都好神仙啊...才学半年啊好恐怖啊QAQ，敝校AU就看各位神仙啦QwQ\n\n下了两天雪，可惜身边全是男生啊QAQ这么棒的意境...~~不过居然也觉得有些浪漫？~~\n\n![越回忆越幸福QwQ](http://i2.bvimg.com/683055/5bf938dba96596c2.jpg)\n![好大雪](http://i2.bvimg.com/683055/c6c39c0ad59231f6.jpg)\n![雪地豪言QwQ](http://i2.bvimg.com/683055/6bf0f0b04ae15c63.jpg)\n![真·神仙♂打架](http://i2.bvimg.com/683055/99d29ee5ca4ce577.jpg)\n![总校人真有情调啊QwQ](http://i2.bvimg.com/683055/2b057e4fb4145d32.jpg)\n#### 2019.3\n\n月初得知HA今年联考，省选日期提前了两个星期，心态有点炸...状态迷失的伏笔。\n\n要出去集训啦...有种自己时日不多了的感觉QwQ。\n\n出去前先给尚宝、卢神和XD过了个集体生日。\n\n![难得的一张大合影](http://i2.bvimg.com/683055/066a2c00cf9fa45d.jpg)\n\n目标芜湖，先到南京，晚上逛了逛夫子庙，第二天fancy学姐带我们在南大转了一圈QwQ...实名表白仙林校区！\n\n![夫子庙](http://i2.bvimg.com/683055/df3b694cfc35caa8.jpg)\n![天天都在偷拍孙神](http://i2.bvimg.com/683055/790b3aec01f063bf.jpg)\n![emmmm...](http://i2.bvimg.com/683055/af6024decb475b4d.jpg)\n![仙林真的很漂亮啊QAQ](http://i2.bvimg.com/683055/589f5d0468e02c8b.jpg)\n![天朗气清w](http://i2.bvimg.com/683055/206b70e28103c25d.jpg)\n![感觉鼓楼校区有些压抑QwQ](http://i2.bvimg.com/683055/a487fe9ab39006ba.jpg)\n\n之后就是安师大附中的十二日集训啦...见识到了许多神仙般的人物~~幸好没有我省的~~，深感自己差得还远...于是自闭并且到现在都没完全恢复过来QAQ。\n\n![夜半三更过天桥w](http://i2.bvimg.com/683055/c6119896ab03c562.jpg)\n![偶遇独自吃饭的卢神！](http://i2.bvimg.com/683055/081d0f14c2cd3668.jpg)\n![长江](http://i1.bvimg.com/683055/aaa4210b72cf92f4.jpg)\n![晚餐](http://i1.bvimg.com/683055/d19567235eaf6aec.jpg)\n![状态不好的时候只能水题度日w](http://i2.bvimg.com/683055/a77536072e2ca30c.jpg)\n![别人的学校...终于觉得郑外更好了QwQ](http://i1.bvimg.com/683055/6de0b9d29a61d4fb.jpg)\n\n临走前go爷又是一顿请，~~还怂恿未成年人喝酒QAQ~~\n\n![注意左手w](http://i1.bvimg.com/683055/b69b46affcacf0a8.jpg)\n![淡定的XD和开心的开昕](http://i1.bvimg.com/683055/4df04e08b240343e.jpg)\n![走啦...走啦](http://i1.bvimg.com/683055/3e28d47fd9694ef9.jpg)\n\n#### 2019.4\n\n十二省联考的月份。\n\nDay1看错题->心态爆炸，Day2没什么心思了结果还挂分。\n退役了。不想说太多。\n\n![考前WF直播...多希望自己以后能站在这个舞台上](http://i1.bvimg.com/683055/5a474108a0e36482.jpg)\n![郑大还是很漂亮的QwQ以后没学上会来这里吗...](http://i1.bvimg.com/683055/23edfc531bbc8f7c.jpg)\n![Day1清晨...本以为是曙光，谁料到是我的夕阳](http://i1.bvimg.com/683055/88f74a2b356581d6.jpg)\n![最后一次聚餐了](http://i1.bvimg.com/683055/b2f1bf0e6b3fd6c1.jpg)\n\n结束了。\n\n### AFO\n\n退役了。出乎自己意料的平静。唯一还耿耿于怀的是郑外的全军覆没。\n这两天经常会想，如果自己当初不看错题面，如果开昕哈希不出锅，如果孙神Day2放平心态，如果尚宝没有多测不清空，如果王子骏NOIp再多哪怕10分...我们或许都可以继续走下去吧，或许就不会落得这样略显悲凉的结局了吧。\n这样的假设只能带给自己心里安慰，并无任何意义——或许连安慰都没法带来。自己再清楚不过了，考场上所有意外情况的发生，究其原因还是因为自己的弱小。竞赛中，菜是原罪——无论是硬实力上的不足，还是心态上的缺失，失败就是失败，技不如人罢了。\n虽然全员翻车太让人意外，也似乎太过残酷——但这就是竞赛吧，这就是生活吧。概率哪怕再小的事情一旦发生了，那就是丝毫不值得惊讶与惋惜的现实了。\n希望能给学弟学妹们留一个教训，也希望郑外OI能挫而愈勇，卷土重来。\n遗憾已经留了，说什么都挽回不了。我们唯一能做的，就是在未来更加小心地走好每一步吧。\n\n前路会与过往不同，\n但精彩纷呈。\n\n与诸君共勉。","content":"<h3 id=\"To-Do-List\"><a href=\"#To-Do-List\" class=\"headerlink\" title=\"To Do List\"></a>To Do List</h3><ol>\n<li>加入信竞  √ Accomplish</li>\n<li>拿到省一  √ Accomplish</li>\n<li>去冬令营  √ Accomplish</li>\n<li>进入省队…</li>\n</ol>\n<p>× Failed.</p>\n<h3 id=\"My-Trip-in-OI\"><a href=\"#My-Trip-in-OI\" class=\"headerlink\" title=\"My Trip in OI\"></a>My Trip in OI</h3><h4 id=\"2018-5\"><a href=\"#2018-5\" class=\"headerlink\" title=\"2018.5\"></a>2018.5</h4><p>从开昕那里借到了紫书！艰难地啃完了基本语法……<br><img src=\"http://i1.bvimg.com/683055/2aa5ffec26b06de8.jpg\" alt=\"循环嵌套当初搞死我了QAQ\"></p>\n<h4 id=\"2018-6\"><a href=\"#2018-6\" class=\"headerlink\" title=\"2018.6\"></a>2018.6</h4><p>给go爷打了一通电话！意外地成功加入信息竞赛！</p>\n<h4 id=\"2018-7\"><a href=\"#2018-7\" class=\"headerlink\" title=\"2018.7\"></a>2018.7</h4><p>在去诸暨的火车上达哥教会了我结构体。满心欢喜以为自己学会了什么不得了的东西。<br>达哥：恭喜你已经入门了！<br>我：？？？才是入门吗……</p>\n<p>海亮真漂亮啊QwQ矿主家孩子的学校。<br><img src=\"http://i1.bvimg.com/683055/8ead460edf1a524c.jpg\" alt=\"调的很失真QAQ不过很喜欢QwQ暴雨将至\"><br><img src=\"http://i1.bvimg.com/683055/2a0045f516910932.jpg\" alt=\"天气很好！\"><br><img src=\"http://i1.bvimg.com/683055/02810fb903b9e316.jpg\" alt=\"这真的不是度假村吗...\"><br><img src=\"http://i1.bvimg.com/683055/55949698e1f7c9f2.jpg\" alt=\"别人家的学校(╯‵□′)╯︵┻━┻\"></p>\n<p>与盒子先生一起看了世界杯决赛！支持的球队决赛从没赢过QAQ<br><img src=\"http://i1.bvimg.com/683055/f274b4d72b5464e3.jpg\" alt=\"Danbo和他的电脑\"></p>\n<p>被小学生初中生吊打了一段时间…然后发现我可以吊打他们了QwQ<br><img src=\"http://i1.bvimg.com/683055/e5670b87ae116705.jpg\" alt=\"当即兴奋地合影留念QwQ\"><br><img src=\"http://i1.bvimg.com/683055/d3ebb52bff89fe0f.jpg\" alt=\"坚持下去就有可能\"></p>\n<h4 id=\"2018-8\"><a href=\"#2018-8\" class=\"headerlink\" title=\"2018.8\"></a>2018.8</h4><p>咕掉了拓展训练…现在想想也没什么可惜的。呆在机房最快乐！虽然确确实实被吊打了一个星期QAQ。<br><img src=\"http://i2.bvimg.com/683055/3f47f7de40243e91.jpg\" alt=\"外卖现场QwQ\"></p>\n<p>期间还撞上了高一的军训文艺汇演……没看多久就被抓回去打代码了233333333。<br><img src=\"http://i1.bvimg.com/683055/9b6eb8b32b0114f5.jpg\" alt=\"QwQ\"><br><img src=\"http://i2.bvimg.com/683055/3acedc06bb37943e.jpg\" alt=\"po一张洒脱的帅哥\"></p>\n<h4 id=\"2018-9\"><a href=\"#2018-9\" class=\"headerlink\" title=\"2018.9\"></a>2018.9</h4><p>停掉了晚自习去机房考试…跟大家慢慢熟起来啦QwQ，也不再天天垫底被吊打…不过依旧很为两个月后的NOIp紧张。</p>\n<p>运动会皓哥主笔、大家谋划为我写的加油稿，我能暖一辈子(ಥ _ ಥ)。<br><img src=\"http://i1.bvimg.com/683055/fefc2be0332c0388.jpg\" alt=\"真的很感动啊QAQ\"></p>\n<h4 id=\"2018-10\"><a href=\"#2018-10\" class=\"headerlink\" title=\"2018.10\"></a>2018.10</h4><p>月考爆炸了…从来没这么垃圾过。跟家长一番争吵后还是继续学了下去。索性直接停了课备战省赛。</p>\n<p>搬到四楼机房呆了一阵，很快乐的一段时光。<br><img src=\"http://i2.bvimg.com/683055/54900f505e155ccd.jpg\" alt=\"想皓哥和尚宝了QAQ还有开心\"></p>\n<h4 id=\"2018-11\"><a href=\"#2018-11\" class=\"headerlink\" title=\"2018.11\"></a>2018.11</h4><p>嘴上说着省二退役，心里却对省队怀着憧憬。于是自己对NOIp成绩的要求就不只是简简单单过线了。</p>\n<p><img src=\"http://i2.bvimg.com/683055/34473dc5d020088f.jpg\" alt=\"一点点紧张\"><br><img src=\"http://i2.bvimg.com/683055/eadba068df4f0372.jpg\" alt=\"CCF真的很严格QwQ\"><br><img src=\"http://i2.bvimg.com/683055/0f2adc746e947908.jpg\" alt=\"NOIp前最后一次机惨233\"></p>\n<p>Day1大起大落…差点死于T1T2。Day2下来本以为能有120+，结果发现T1写挂12分，T2…</p>\n<p><img src=\"http://i2.bvimg.com/683055/c68b6089d455a505.png\" alt=\"智障Micardi在线傻逼QAQ\"></p>\n<p>×3-&gt;×6÷2，取模意义下直接全挂…不过现在看来，无伤大雅了。</p>\n<p>皓哥和达哥要退役了，曾经对我OI学习帮助最大的两位神仙啊…第一次这么真切地感受到了竞赛的残酷和无常。很难过，却不知道该说些什么。</p>\n<p>很多人的命运都是未知…但有些回忆已是永恒。</p>\n<p><img src=\"http://i1.bvimg.com/683055/c1d34540a62bc01a.jpg\" alt=\"辣椒油同学！\"><br><img src=\"http://i1.bvimg.com/683055/a9c87d88fe7d7f25.jpg\" alt=\"省赛前清理机房...伤感\"><br><img src=\"http://i1.bvimg.com/683055/63dcd947a53e8d30.jpg\" alt=\"省赛后聚餐！两位神仙嗷QwQ\"><br><img src=\"http://i1.bvimg.com/683055/57c34b433f5e9fb4.jpg\" alt=\"love u all!\"></p>\n<h4 id=\"2018-12\"><a href=\"#2018-12\" class=\"headerlink\" title=\"2018.12\"></a>2018.12</h4><p>文化课补得及其开心…假的！还是OI才能带给我快乐啊QAQ！</p>\n<p>去参加了市赛，抱大腿拿了个团队第二。</p>\n<p><img src=\"http://i2.bvimg.com/683055/fb0252370824ebbf.jpg\" alt=\"方舟tql！！！\"></p>\n<h4 id=\"2019-1\"><a href=\"#2019-1\" class=\"headerlink\" title=\"2019.1\"></a>2019.1</h4><p>决定了继续走下去,于是疯狂补习省选知识点。</p>\n<p>去到了Winter Camp，虽然天天掉线却觉得受益匪浅——最重要的是非常开心啊QwQ。</p>\n<p><img src=\"http://i2.bvimg.com/683055/3f49952e8350411d.jpg\" alt=\"签到板上看到了许多神仙的名字\"><br><img src=\"http://i2.bvimg.com/683055/0a8c2deec978004d.jpg\" alt=\"为松松和他的小黄鸭打call！\"><br><img src=\"http://i2.bvimg.com/683055/bd580a300f5a94ea.jpg\" alt=\"某人说有入藏的感觉？\"><br><img src=\"http://i2.bvimg.com/683055/8e66b8533dd982e4.jpg\" alt=\"好基友QwQ\"><br><img src=\"http://i2.bvimg.com/683055/b32602d887ff72e6.jpg\" alt=\"HA省夜会！\"><br><img src=\"http://i1.bvimg.com/683055/6bfa4abe75394b28.jpg\" alt=\"喜欢夜深人静码代码的感觉嗷\"></p>\n<h4 id=\"2019-2\"><a href=\"#2019-2\" class=\"headerlink\" title=\"2019.2\"></a>2019.2</h4><p>春节七天乐，之后就开始<del>欢快的</del>紧张刺激的省选备战。</p>\n<p>在总校苟了七八天？zzy太神啦lch太神啦xd太神啦syt太神啦…都好神仙啊…才学半年啊好恐怖啊QAQ，敝校AU就看各位神仙啦QwQ</p>\n<p>下了两天雪，可惜身边全是男生啊QAQ这么棒的意境…<del>不过居然也觉得有些浪漫？</del></p>\n<p><img src=\"http://i2.bvimg.com/683055/5bf938dba96596c2.jpg\" alt=\"越回忆越幸福QwQ\"><br><img src=\"http://i2.bvimg.com/683055/c6c39c0ad59231f6.jpg\" alt=\"好大雪\"><br><img src=\"http://i2.bvimg.com/683055/6bf0f0b04ae15c63.jpg\" alt=\"雪地豪言QwQ\"><br><img src=\"http://i2.bvimg.com/683055/99d29ee5ca4ce577.jpg\" alt=\"真·神仙♂打架\"><br><img src=\"http://i2.bvimg.com/683055/2b057e4fb4145d32.jpg\" alt=\"总校人真有情调啊QwQ\"></p>\n<h4 id=\"2019-3\"><a href=\"#2019-3\" class=\"headerlink\" title=\"2019.3\"></a>2019.3</h4><p>月初得知HA今年联考，省选日期提前了两个星期，心态有点炸…状态迷失的伏笔。</p>\n<p>要出去集训啦…有种自己时日不多了的感觉QwQ。</p>\n<p>出去前先给尚宝、卢神和XD过了个集体生日。</p>\n<p><img src=\"http://i2.bvimg.com/683055/066a2c00cf9fa45d.jpg\" alt=\"难得的一张大合影\"></p>\n<p>目标芜湖，先到南京，晚上逛了逛夫子庙，第二天fancy学姐带我们在南大转了一圈QwQ…实名表白仙林校区！</p>\n<p><img src=\"http://i2.bvimg.com/683055/df3b694cfc35caa8.jpg\" alt=\"夫子庙\"><br><img src=\"http://i2.bvimg.com/683055/790b3aec01f063bf.jpg\" alt=\"天天都在偷拍孙神\"><br><img src=\"http://i2.bvimg.com/683055/af6024decb475b4d.jpg\" alt=\"emmmm...\"><br><img src=\"http://i2.bvimg.com/683055/589f5d0468e02c8b.jpg\" alt=\"仙林真的很漂亮啊QAQ\"><br><img src=\"http://i2.bvimg.com/683055/206b70e28103c25d.jpg\" alt=\"天朗气清w\"><br><img src=\"http://i2.bvimg.com/683055/a487fe9ab39006ba.jpg\" alt=\"感觉鼓楼校区有些压抑QwQ\"></p>\n<p>之后就是安师大附中的十二日集训啦…见识到了许多神仙般的人物<del>幸好没有我省的</del>，深感自己差得还远…于是自闭并且到现在都没完全恢复过来QAQ。</p>\n<p><img src=\"http://i2.bvimg.com/683055/c6119896ab03c562.jpg\" alt=\"夜半三更过天桥w\"><br><img src=\"http://i2.bvimg.com/683055/081d0f14c2cd3668.jpg\" alt=\"偶遇独自吃饭的卢神！\"><br><img src=\"http://i1.bvimg.com/683055/aaa4210b72cf92f4.jpg\" alt=\"长江\"><br><img src=\"http://i1.bvimg.com/683055/d19567235eaf6aec.jpg\" alt=\"晚餐\"><br><img src=\"http://i2.bvimg.com/683055/a77536072e2ca30c.jpg\" alt=\"状态不好的时候只能水题度日w\"><br><img src=\"http://i1.bvimg.com/683055/6de0b9d29a61d4fb.jpg\" alt=\"别人的学校...终于觉得郑外更好了QwQ\"></p>\n<p>临走前go爷又是一顿请，<del>还怂恿未成年人喝酒QAQ</del></p>\n<p><img src=\"http://i1.bvimg.com/683055/b69b46affcacf0a8.jpg\" alt=\"注意左手w\"><br><img src=\"http://i1.bvimg.com/683055/4df04e08b240343e.jpg\" alt=\"淡定的XD和开心的开昕\"><br><img src=\"http://i1.bvimg.com/683055/3e28d47fd9694ef9.jpg\" alt=\"走啦...走啦\"></p>\n<h4 id=\"2019-4\"><a href=\"#2019-4\" class=\"headerlink\" title=\"2019.4\"></a>2019.4</h4><p>十二省联考的月份。</p>\n<p>Day1看错题-&gt;心态爆炸，Day2没什么心思了结果还挂分。<br>退役了。不想说太多。</p>\n<p><img src=\"http://i1.bvimg.com/683055/5a474108a0e36482.jpg\" alt=\"考前WF直播...多希望自己以后能站在这个舞台上\"><br><img src=\"http://i1.bvimg.com/683055/23edfc531bbc8f7c.jpg\" alt=\"郑大还是很漂亮的QwQ以后没学上会来这里吗...\"><br><img src=\"http://i1.bvimg.com/683055/88f74a2b356581d6.jpg\" alt=\"Day1清晨...本以为是曙光，谁料到是我的夕阳\"><br><img src=\"http://i1.bvimg.com/683055/b2f1bf0e6b3fd6c1.jpg\" alt=\"最后一次聚餐了\"></p>\n<p>结束了。</p>\n<h3 id=\"AFO\"><a href=\"#AFO\" class=\"headerlink\" title=\"AFO\"></a>AFO</h3><p>退役了。出乎自己意料的平静。唯一还耿耿于怀的是郑外的全军覆没。<br>这两天经常会想，如果自己当初不看错题面，如果开昕哈希不出锅，如果孙神Day2放平心态，如果尚宝没有多测不清空，如果王子骏NOIp再多哪怕10分…我们或许都可以继续走下去吧，或许就不会落得这样略显悲凉的结局了吧。<br>这样的假设只能带给自己心里安慰，并无任何意义——或许连安慰都没法带来。自己再清楚不过了，考场上所有意外情况的发生，究其原因还是因为自己的弱小。竞赛中，菜是原罪——无论是硬实力上的不足，还是心态上的缺失，失败就是失败，技不如人罢了。<br>虽然全员翻车太让人意外，也似乎太过残酷——但这就是竞赛吧，这就是生活吧。概率哪怕再小的事情一旦发生了，那就是丝毫不值得惊讶与惋惜的现实了。<br>希望能给学弟学妹们留一个教训，也希望郑外OI能挫而愈勇，卷土重来。<br>遗憾已经留了，说什么都挽回不了。我们唯一能做的，就是在未来更加小心地走好每一步吧。</p>\n<p>前路会与过往不同，<br>但精彩纷呈。</p>\n<p>与诸君共勉。</p>\n","slug":"退役随笔","updated":"2019-04-08T07:38:17.238Z","link":"","permalink":"https://micardi.github.io/2019/04/08/退役随笔/","excerpt":"","categories":[{"name":"随笔","slug":"随笔","permalink":"https://micardi.github.io/categories/随笔/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://micardi.github.io/tags/OI/"}]},{"title":"一句话题解","date":"2019-03-29T12:30:00.785Z","path":"2019/03/29/一句话题解/","text":"做过的一些题目并无需细讲，却很值得人玩味，在此做个汇总，也算是方便自己复习整理咯QwQ. 【CEOI2015】世界冰球锦标赛 折半搜索【USACO10MAR】Test Taking 奇妙的分析【POI2011】TEM-temperature 单调队列【CQOI2006】简单题 真的好简单树状数组【NOI2014】动物园 KMP变种【SDOI2014】旅行 动态开点线段树+树剖【国家集训队】墨墨的等式 同余最短路【NOI2009】变换序列 倒着跑匈牙利【TJOI2018】数学计算 线段树 以时间为轴Period KMP求最小循环节【NOI2014】起床困难综合症 按位贪心灾后重建 对Floyd中转点的理解砝码称重 枚举+背包 可用bitset【HNOI2009】梦幻布丁 链表实现简易版splay【NOIp2013】火柴排队 树状数组【NOIp2015】子串 DP哈希冲突 对值域进行分块维护【HNOI2012】永无乡 splay+并查集+启发式合并【JSOI2008】星球大战 离线处理 断边-&gt;加边 并查集即可【HNOI2010】弹飞绵羊 标算LCT 分块瞎搞很interesting垃圾陷阱 背包变种 怎么这么少QAQ.","raw":"---\ntitle: 一句话题解\ntop: 9999\ntags: \n- OI\ncategories: \n- 题解\n---\n\n做过的一些题目并无需细讲，却很值得人玩味，在此做个汇总，也算是方便自己复习整理咯QwQ.\n\n[【CEOI2015】世界冰球锦标赛](https://www.luogu.org/problemnew/show/P4799) 折半搜索\n[【USACO10MAR】Test Taking](https://www.luogu.org/problemnew/show/P2988) 奇妙的分析\n[【POI2011】TEM-temperature](https://www.luogu.org/problemnew/show/P3522) 单调队列\n[【CQOI2006】简单题](https://www.luogu.org/problemnew/show/P5057) ~~真的好简单~~树状数组\n[【NOI2014】动物园](https://www.luogu.org/problemnew/show/P2375) KMP变种\n[【SDOI2014】旅行](https://www.luogu.org/problemnew/show/P3313) 动态开点线段树+树剖\n[【国家集训队】墨墨的等式](https://www.luogu.org/problemnew/show/P2371) 同余最短路\n[【NOI2009】变换序列](https://www.luogu.org/problemnew/show/P1963) 倒着跑匈牙利\n[【TJOI2018】数学计算](https://www.luogu.org/problemnew/show/P4588) 线段树 以时间为轴\n[Period](https://www.luogu.org/problemnew/show/SP263) KMP求最小循环节\n[【NOI2014】起床困难综合症](https://www.luogu.org/problemnew/show/P2114) 按位贪心\n[灾后重建](https://www.luogu.org/problemnew/show/P1119) 对Floyd中转点的理解\n[砝码称重](https://www.luogu.org/problemnew/show/P1441) 枚举+背包 可用bitset\n[【HNOI2009】梦幻布丁](https://www.luogu.org/problemnew/show/P3201) 链表实现简易版splay\n[【NOIp2013】火柴排队](https://www.luogu.org/problemnew/show/P1966) 树状数组\n[【NOIp2015】子串](https://www.luogu.org/problemnew/show/P2679) DP\n[哈希冲突](https://www.luogu.org/problemnew/show/P3396) 对值域进行分块维护\n[【HNOI2012】永无乡](https://www.luogu.org/problemnew/show/P3224) splay+并查集+启发式合并\n[【JSOI2008】星球大战](https://www.luogu.org/problemnew/show/P1197) 离线处理 断边->加边 并查集即可\n[【HNOI2010】弹飞绵羊](https://www.luogu.org/problemnew/show/P3203) 标算LCT 分块瞎搞很interesting\n[垃圾陷阱](https://www.luogu.org/problemnew/show/P1156) 背包变种\n\n怎么这么少QAQ.","content":"<p>做过的一些题目并无需细讲，却很值得人玩味，在此做个汇总，也算是方便自己复习整理咯QwQ.</p>\n<p><a href=\"https://www.luogu.org/problemnew/show/P4799\" target=\"_blank\" rel=\"noopener\">【CEOI2015】世界冰球锦标赛</a> 折半搜索<br><a href=\"https://www.luogu.org/problemnew/show/P2988\" target=\"_blank\" rel=\"noopener\">【USACO10MAR】Test Taking</a> 奇妙的分析<br><a href=\"https://www.luogu.org/problemnew/show/P3522\" target=\"_blank\" rel=\"noopener\">【POI2011】TEM-temperature</a> 单调队列<br><a href=\"https://www.luogu.org/problemnew/show/P5057\" target=\"_blank\" rel=\"noopener\">【CQOI2006】简单题</a> <del>真的好简单</del>树状数组<br><a href=\"https://www.luogu.org/problemnew/show/P2375\" target=\"_blank\" rel=\"noopener\">【NOI2014】动物园</a> KMP变种<br><a href=\"https://www.luogu.org/problemnew/show/P3313\" target=\"_blank\" rel=\"noopener\">【SDOI2014】旅行</a> 动态开点线段树+树剖<br><a href=\"https://www.luogu.org/problemnew/show/P2371\" target=\"_blank\" rel=\"noopener\">【国家集训队】墨墨的等式</a> 同余最短路<br><a href=\"https://www.luogu.org/problemnew/show/P1963\" target=\"_blank\" rel=\"noopener\">【NOI2009】变换序列</a> 倒着跑匈牙利<br><a href=\"https://www.luogu.org/problemnew/show/P4588\" target=\"_blank\" rel=\"noopener\">【TJOI2018】数学计算</a> 线段树 以时间为轴<br><a href=\"https://www.luogu.org/problemnew/show/SP263\" target=\"_blank\" rel=\"noopener\">Period</a> KMP求最小循环节<br><a href=\"https://www.luogu.org/problemnew/show/P2114\" target=\"_blank\" rel=\"noopener\">【NOI2014】起床困难综合症</a> 按位贪心<br><a href=\"https://www.luogu.org/problemnew/show/P1119\" target=\"_blank\" rel=\"noopener\">灾后重建</a> 对Floyd中转点的理解<br><a href=\"https://www.luogu.org/problemnew/show/P1441\" target=\"_blank\" rel=\"noopener\">砝码称重</a> 枚举+背包 可用bitset<br><a href=\"https://www.luogu.org/problemnew/show/P3201\" target=\"_blank\" rel=\"noopener\">【HNOI2009】梦幻布丁</a> 链表实现简易版splay<br><a href=\"https://www.luogu.org/problemnew/show/P1966\" target=\"_blank\" rel=\"noopener\">【NOIp2013】火柴排队</a> 树状数组<br><a href=\"https://www.luogu.org/problemnew/show/P2679\" target=\"_blank\" rel=\"noopener\">【NOIp2015】子串</a> DP<br><a href=\"https://www.luogu.org/problemnew/show/P3396\" target=\"_blank\" rel=\"noopener\">哈希冲突</a> 对值域进行分块维护<br><a href=\"https://www.luogu.org/problemnew/show/P3224\" target=\"_blank\" rel=\"noopener\">【HNOI2012】永无乡</a> splay+并查集+启发式合并<br><a href=\"https://www.luogu.org/problemnew/show/P1197\" target=\"_blank\" rel=\"noopener\">【JSOI2008】星球大战</a> 离线处理 断边-&gt;加边 并查集即可<br><a href=\"https://www.luogu.org/problemnew/show/P3203\" target=\"_blank\" rel=\"noopener\">【HNOI2010】弹飞绵羊</a> 标算LCT 分块瞎搞很interesting<br><a href=\"https://www.luogu.org/problemnew/show/P1156\" target=\"_blank\" rel=\"noopener\">垃圾陷阱</a> 背包变种</p>\n<p>怎么这么少QAQ.</p>\n","slug":"一句话题解","updated":"2019-03-29T13:28:34.716Z","link":"","permalink":"https://micardi.github.io/2019/03/29/一句话题解/","excerpt":"","categories":[{"name":"题解","slug":"题解","permalink":"https://micardi.github.io/categories/题解/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://micardi.github.io/tags/OI/"}]},{"title":"解决Xor问题的利器——线性基","date":"2019-03-29T11:35:09.805Z","path":"2019/03/29/线性基随笔/","text":"位运算是算法竞赛独特而有趣的一类知识，Xor（异或）则是相关题目中出现较为频繁的一种运算。 Xor具有以下特点/性质：交换律：a^b=b^a结合律：a^(b^c)=(a^b)^c自零性：a^a=0自反性：若a^b=c,则c^b=a,c^a=b 而在Xor一类题目中，我们常常会面对类似这样的问题：求出给定集合产生的所有异或值中最大/k大/最小/k小值。 我们知道，枚举所有子集的异或值复杂度为指数级别，难以处理集合规模较大的问题——不过我们注意到，所有子集产生的异或值会有许多重复的，我们要简化问题的关键就在于如何去重。我们就会有这样一个想法——能否构造出一个集合，使其既能保证与原集合异或值域相同，又能大大缩小集合规模呢？于是——线性基，应运而生了。 什么是线性基？“基”的概念来源于线性代数，线性空间中任意一个元素都可以唯一地表示成基向量的线性组合。 而线性基是一种特殊的基。一个集合的线性基具有如下基本性质： 其子集的异或值域与原集合的异或值域相同 线性基是所有满足第一条性质的集合中最小的集合 线性基无法通过异或得到0 如何构造线性基？我们通常用数组p来表示线性基。其中p[i]表示：二进制最高位的1在第i位的数。1234567891011121314#define ll long longconst int N=64;ll p[N];inline void ins(ll x)//向线性基中插入x&#123; for(int j=63;~j;--j) &#123; if(x&gt;&gt;j&amp;1)//如果x第j位为1 &#123; if(!p[j])&#123;p[j]=x;break;&#125;//p[j]尚未存在，那么直接令p[j]=x，不要忘记break else x^=p[j];//否则就让x异或上当前的p[j]，继续 &#125; &#125;&#125; 考虑这样构造为什么能维护三个基本性质。 对于性质一：上述方法构造出的线性基之所以能维护性质一，在于该线性基能表示出原集合中的每一个数。 设原集合为x1、x2、x3……xn，现在x1已经被插入线性基，我们插入x2。 如果x1与x2最高位的1不在同一位上，比如x1=4(100),x2=2(010),由上述构造方法知：x1不会对x2产生影响，x2被顺利插入。 如果x1与x2最高位的1在同一位上，比如x1=4(100),x2=6(110),那么x2会与x1进行Xor运算。设y=x1^x2,由Xor的自反性知x2=x1^y,那么x2就可以用x1^y表示出来。插入x3、x4……xn同理。因此我们可以用一组线性基表示出原集合中的所有数，进而可以得到原集合中的所有异或值。 对于性质二：这还是非常显然的。 我们在构造线性基时，会不断进行Xor的操作，如果一个数x经过不断Xor后变为0，说明这个数可以由线性基中若干个数表示出来——因为由Xor自零性知，只有当(p[i]^p[j]^p[k]^…^p[w])==x时，x才会变成0。而当且仅当这种情况下x才不会被插入线性基——换句话说，如果一个数被插入了线性基，说明这个数无法用其他数经过Xor得到。因此，线性基中的每一个数都无法删去或者合并，因为若被删去或者合并，这个数就没办法表示出来了。所以线性基是满足性质一的最小集合，进而保证了性质二成立。 对于性质三：前两条性质一旦保证，第三条性质也呼之欲出了。 假设线性基可以通过相互Xor得到0，那么一定有(p[i]^p[j]^…^p[k])==(p[a]^p[b]^…^p[c]),由Xor自反性知，有(p[i]^p[j]^p[k]^p[a]^…^p[b])==p[c]，即p[c]可以用其它的基表示出来，与性质二冲突，假设不成立。 了解了基本性质与构造方法后，我们就可以用线性基去解决一些题目了。至于线性基的一些特殊性质，我们就结合题目来理解吧： 例题 最大异或和 线性基模板题。 一个很显然的贪心：我们从高位到低位遍历线性基，若当前ans与当前p[i]进行Xor操作后变大了，我们就令ans=(ans^p[i])。贪心正确性？对于线性基中每一个p[i]以及任意j&lt;i，一定有p[j]第i位为0——结合构造方法，这个性质不难想到。那么我们每次都尽量保证当前最高位更大，之后在低位一定不会对高位有影响。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const int N=55;int n;ll a[N],p[107];ll read()&#123; ll f=1,a=0;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;a=(a&lt;&lt;3)+(a&lt;&lt;1)+ch-'0';ch=getchar();&#125; return a*f;&#125;inline void Xian_Xing_Ji(ll x) &#123; for(register ll i=60;i&gt;=0;--i) &#123; if(!(x&gt;&gt;i))continue; else &#123; if(!p[i])&#123; p[i]=x; break; &#125; else x^=p[i]; &#125; &#125;&#125;int main()&#123; n=read(); for(register int i=1;i&lt;=n;++i) Xian_Xing_Ji(a[i]=read()); ll ans=0; for(register int i=60;i&gt;=0;--i) if((ans^p[i])&gt;ans)ans^=p[i]; cout&lt;&lt;ans; return 0;&#125; k大异或和 线性基模板题。不过显然没有上题那么模板化——而且题目叫“k小异或和”似乎妥当一些。 首先我们需要介绍一个特殊性质：线性基中的元素相互Xor，线性基Xor值域不变——比如，设线性基中有元素x,y,现在令x=x^y,那么由Xor的自反性知，原来的x依旧可以用现在的x异或y得到，所以原来线性基的异或集合是不会变的。知道这个性质有什么用？本题需要利用这个性质对常规线性基进行改造。 我们令p[i]的意义稍稍改变一下：p[i]表示原Xor集合中，最高位的1在第i位的所有数中最小的一个。例如：若原Xor集合中最高位的1在第3位的有5(101),6(110),那么p[2]就应该等于5。接下来，我们要用一个数组a记录非空空的p——比如，p[0]=1,p[1]=0,p[2]=5,我们就要去掉p[1]——因为空的线性基显然不会对答案有贡献，这样就变成了a[0]=1,a[1]=5。然后，我们对k进行二进制拆分：若k二进制第i位为1，那么就让当前ans^p[i]，最后的ans就是所求了。 为什么这么做？我们借助一个例子理解一下：我们可以用10进制联想：第15小的正整数是谁？十位上第1小的(10)加上各位上第五小的(5)——二进制也同理。若k=5(101)，其实就是要求(非空)第2位上第一小的数Xor上第0位上第一小的数，就是a[2]^a[0]了(想一想，为什么是非空)。 这道题还有两个需要注意的地方： 怎么求改造后的p[i]？从高位到低位遍历原始线性基，对于每一个p[i]，若其第j位(j&lt;i)为1，就让p[i]=p[i]^p[j]。如何保证这样得到的p[i]是第i位中最小的？这里偷个懒……就不给详细解释了，大家感性理解：这样构造的话我们是让p[i]中比第i位低的1都尽量变成0——我们如何找十进制百位最小的数？显然让是比百位低的位上都为0。二进制也同理，我们要找当前Xor集合中第i位为1的最小数，自然也是尽量让比第i位低的位上都为0啊。同时，由前文所述特殊性质知，这样改造出的线性基与原集合Xor集合仍然相同。 由于线性基无法通过Xor得到0，所以若原集合可以通过Xor得到0，那么我们所求原集合中第k小实际上是线性基中的第k-1小。怎么判断原集合能否通过Xor得到0？若构造出线性基后发现线性基中的数比原集合中的数少，说明原集合可以通过相互Xor得到0——为什么？若原集合中的数相互Xor能得到0，一定有(x1^x2^…^xn)==0,即(x1^…^x2)==xn,那么由基本性质二可知，xn无法被插入线性基，线性基中数的个数就会比原集合中的数少。 然后我们就可以水过这道题了：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;#define ll long long using namespace std;ll p[64],a[64],x,k;int n,m,cnt=0;inline void ins(ll x)&#123; for(int j=50;~j;--j) &#123; if(x&gt;&gt;j&amp;1) &#123; if(!p[j])&#123;p[j]=x;break;&#125; else x^=p[j]; &#125; &#125;&#125;int main()&#123; scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;++i) &#123; scanf(\"%lld\",&amp;x); ins(x); &#125; for(int i=50;~i;--i) for(int j=i-1;~j;--j) if(p[i]&gt;&gt;j&amp;1)p[i]^=p[j]; for(int i=0;i&lt;=50;++i) if(p[i])a[cnt++]=p[i]; scanf(\"%d\",&amp;m); while(m--) &#123; scanf(\"%lld\",&amp;k); if(cnt!=n)--k; if(k&gt;=(1ll&lt;&lt;cnt))puts(\"-1\"); else &#123; ll ans=0; for(int i=0;i&lt;cnt;++i) if(k&gt;&gt;i&amp;1)ans^=a[i]; printf(\"%lld\\n\",ans); &#125; &#125; return 0;&#125; CQOI2013新Nim游戏 很有意思的一道线性基题目。 我们首先要知道传统Nim游戏如何判断胜负：设火柴堆数分别为x1、x2…xn，那么先手必胜当且仅当x1^x2^…^xn不为0，否则先手必败。具体证明属于博弈论相关，在此不再赘述。这道题与传统Nim游戏不一样的地方在于，第一轮双方是可以随便拿整堆火柴的——那么若要先手必胜，先手方必须留下一个局面，使得后手无论怎么做都无法令剩下的所有石子异或为0。集合内所有子集Xor值均不为0？一眼线性基！只要先手方留给后手方一个线性基，那不就是先手必胜了吗? 做法就很显然了：对于每一堆火柴，我们判断它是否可以被插入线性基，若可以就插入，否则就把这一堆石子取走。有一个需要注意的地方：题目还要求拿走的火柴数目的最小？我们可以贪心：将火柴堆数从大到小排列后进行上述操作。为什么是从大到小？我们这么想：我们肯定要先让大的数都尽量插入线性基，这样等到不得不拿走火柴的时候，拿走的就都是小的了。自己举几个例子，相信并不难理解。 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const int N=107;ll p[64],a[N];int k;inline bool ins(ll x)&#123; for(register int i=63;~i;--i)&#123; if(x&gt;&gt;i&amp;1)&#123; if(!p[i])&#123; p[i]=x; return true; &#125; else x^=p[i]; &#125; &#125; return false;&#125;ll ans;int main()&#123; scanf(\"%d\",&amp;k); for(register int i=1;i&lt;=k;++i) scanf(\"%lld\",&amp;a[i]); sort(a+1,a+k+1); for(register int i=k;i;--i) if(!ins(a[i]))ans+=a[i]; cout&lt;&lt;(ll)ans; return 0;&#125; -albus就是要第一个出场 又是一道需要用到一个特殊性质的题。我们设线性基非空长度为k(如p[0]=1,p[2]=4,p[5]=32,则k=3)，则线性基所能表示的Xor集合里共有2的k次方个不相同的数——这个很显然，每一个基都有选或不选两种可能。而设原集合长度为n，则每一种Xor值都出现了2的n-k次方次。这是为什么？我们可以这么考虑：因为原集合的线性基可以表示出所有Xor值，所以除了k个基以外，其它的n-k个数对Xor值并没有贡献，因此我们可以把它们都看成0；与此同时，k个基每产生一个异或值，都可以与这n-k个0继续Xor——从n-k个0中选择若干个零有几种方案呢？2的n-k次方种。 接下来我们要求给定的Q是第几大——我们依旧对线性基进行一个小小改造，我们用一个数组b存储非空p[i]的i(比如p[0]=1,p[1]=0,p[2]=4,则b[0]=0,b[1]=2),如果Q二进制中第b[i]位为1，则对答案贡献为2的i次方——因为说明到第i位时，是有这么多Xor值是比Q小的。每种Xor值都出现了2的(n-k)次方次，快速幂在最后处理即可。最后答案要+1，因为之前我们求的是有多少Xor值比Q小，加上1才是我们想要的排名。1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;#define ll long long#define mod 10086using namespace std;const int N=2e5+7;ll p[63],a[N],b[N];int n,k,tot,sum;inline void ins(ll x)&#123; for(register int i=63;~i;--i)&#123; if(x&gt;&gt;i&amp;1)&#123; if(!p[i])&#123; p[i]=x; break; &#125; else x^=p[i]; &#125; &#125;&#125;ll qpow(ll a,ll b)&#123; ll ans=1; while(b)&#123; if(b&amp;1)ans=(a*ans)%mod; b&gt;&gt;=1; a=(a*a)%mod; &#125; return ans;&#125;int main()&#123; scanf(\"%d\",&amp;n); for(register int i=1;i&lt;=n;++i)scanf(\"%lld\",&amp;a[i]),ins(a[i]); scanf(\"%d\",&amp;k); for(register int i=0;i&lt;64;++i) if(p[i])b[tot++]=i; for(register int i=0;i&lt;tot;++i) if(k&gt;&gt;b[i]&amp;1)sum+=1ll&lt;&lt;i; cout&lt;&lt;(1ll*sum*qpow(2,n-tot)+1)%mod; return 0;&#125; 【WC2011】最大Xor和路径 非常经典的题目。可以说是图上线性基的板子题。 我们考虑：从1号点到n号点的路径，可以划分成一些简单路径和环：上图是一个最简单的例子，图中1-2-3-9是一条简单路径，而2-7-8、5-4-6构成两个环。而如果我们走进了一个环，那么要么把一整个环从头到尾遍历一遍，这样做环上所有路径的权值都会对Xor和产生贡献；要么我们走一半掉头回去——由Xor的自反性可知，之前经过的环上路径权值都又被消掉了，对答案没有贡献。于是我们得到了一个结论：对于一个环，它对答案的贡献只能是环上所有路径的Xor和（选了这个环）或者为0（不选这个环）。那么我们就有了一个思路——如果从1到n只有一条简单路径，那么我们显然必须走这条路，同时我们可以在途中经过一些环来更新答案。于是问题变成了：给你一个初始值（简单路径Xor和），再给你一些数（所有环各自的Xor和），让你求从这些数中选出若干后与初始值的最大Xor和值——这不就成了线性基模板题吗？我们先求出1到n的简单路径Xor和，再dfs出所有环各自的Xor和，把这些环上Xor和丢进线性基，以1到n的简单路径Xor和为初始值做一遍最大异或和即可。那如果1到n有多条简单路径呢？其实是一样的！我们一开始任意选择一条简单路径后，按照上述做法做一遍就好。为什么可以随意选择初始的简单路径？很明显，如果从1到n有多条简单路径，那么它们相互构成了一个大环。以上图为例，图中有3-4-5、1-2-7-6两个环，从1到n的简单路径有1-2-7、1-6-7两条。假设我们一开始选择了1-2-7这条路并不是最优的，那么在按照最大异或和的做法进行的时候，它就会被1-2-7-6这个大环Xor掉，由Xor自反性可知，这相当于我们一开始选择了更优的1-6-7这条路径，依然可以保证答案的正确性。于是对于这一类题目我们就有了做法：把所有环上Xor和扔进线性基，随便拎出来一条简单路径当初始值，跑一遍最大Xor和即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const int N=3e7+9;struct nod&#123; int nx,to; ll va;&#125;a[N];ll p[N],dis[N];int vis[N],head[N],tot,n,m;inline void add(int fr,int to,ll va)&#123;a[++tot].to=to;a[tot].nx=head[fr];a[tot].va=va;head[fr]=tot;&#125;inline void ins(ll x)&#123; for(register int i=63;i&gt;=0;--i)&#123; if((x&gt;&gt;i)&amp;1)&#123; if(!p[i])&#123; p[i]=x; break; &#125; x^=p[i]; &#125; &#125;&#125;void dfs(int x,ll res)&#123; vis[x]=1;dis[x]=res; for(register int i=head[x];i;i=a[i].nx) if(!vis[a[i].to])dfs(a[i].to,res^a[i].va); else ins(res^dis[a[i].to]^a[i].va); &#125;inline ll que(ll x)&#123; ll res=x; for(register int i=63;i&gt;=0;--i) if((res^p[i])&gt;res)res^=p[i]; return res;&#125;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;m); for(register int i=1;i&lt;=m;++i) &#123; int x,y;ll v; scanf(\"%d%d%lld\",&amp;x,&amp;y,&amp;v); add(x,y,v);add(y,x,v); &#125; dfs(1,0); printf(\"%lld\",que(dis[n])); return 0;&#125; 【HAOI2017】八纵八横 HAOI为什么考板子题啊其实相较上一题这道题还是难度更大的。原因在于：这道题中要求有删除和修改操作，可传统线性基并不支持删除与修改。首先，我们可以转换思路：把修改后的边看成一条新出现的边，修改前的边就当把它删掉了——这样以来我们就只用考虑如何处理删除操作。避开删除，只进行插入？我们想到了线段树分治！以时间为轴，存储每条道路出现的时间区间，每次把一个时间段内存在的道路插入线性基，到了某一个具体时刻直接输出即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;bits/stdc++.h&gt;#define N 1005#define mid ((l+r)&gt;&gt;1)#define ll bitset&lt;N&gt;using namespace std;int n,m,q;char s[N];int to[N],nxt[N],head[N],cnt;ll ww[N],dis[N];int pos[N],id,tot,fa[N];vector&lt;int&gt;v[N&lt;&lt;3];struct edge&#123; int u,v,l,r; ll w;&#125;e[N&lt;&lt;4]; void link(int u,int v,ll w)&#123; to[++cnt]=v;nxt[cnt]=head[u];ww[cnt]=w;head[u]=cnt; to[++cnt]=u;nxt[cnt]=head[v];ww[cnt]=w;head[v]=cnt;&#125;int find(int x)&#123;return x==fa[x]?x:fa[x]=find(fa[x]);&#125;ll gl()&#123;scanf(\"%s\",s+1);int len=strlen(s+1);ll x;x.reset();for(register int i=1;i&lt;=len;++i)x[len-i]=s[i]-'0';return x;&#125;struct xxj&#123; ll p[N]; void ins(ll x)&#123; for(register int i=N-1;~i;--i) if(x[i])&#123; if(!p[i].any())&#123;p[i]=x;return;&#125; x^=p[i]; &#125; &#125; ll cal()&#123; ll x;x.reset(); for(register int i=N-1;~i;--i) if(!x[i])x^=p[i]; return x; &#125;&#125;tmp;void print(ll x)&#123; int i=N-1;while (!x[i]) --i; while (~i) putchar(x[i]+'0'),--i;puts(\"\");&#125;void dfs(int u,int f)&#123; for(register int i=head[u];~i;i=nxt[i]) &#123; int v=to[i]; if(v==f)continue; dis[v]=dis[u]^ww[i]; dfs(v,u); &#125;&#125;void modi(int x,int l,int r,int ql,int qr,int i)&#123; if(l&gt;=ql&amp;&amp;r&lt;=qr)&#123;v[x].push_back(i);return;&#125; if(ql&lt;=mid)modi(x&lt;&lt;1,l,mid,ql,qr,i); if(qr&gt;mid)modi(x&lt;&lt;1|1,mid+1,r,ql,qr,i);&#125;void query(int x,int l,int r,xxj S)&#123; int len=v[x].size(); for(register int i=0;i&lt;len;++i) S.ins(dis[e[v[x][i]].u]^dis[e[v[x][i]].v]^e[v[x][i]].w); if(l==r)&#123;print(S.cal());return;&#125; query(x&lt;&lt;1,l,mid,S);query(x&lt;&lt;1|1,mid+1,r,S);&#125;int main()&#123; memset(head,-1,sizeof(head)); scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;q); for(register int i=1;i&lt;=n;++i)fa[i]=i; for(register int i=1;i&lt;=m;++i) &#123; int u,v; scanf(\"%d%d\",&amp;u,&amp;v); ll w=gl(); if(find(u)!=find(v))link(u,v,w),fa[find(u)]=find(v); else e[++tot]=(edge)&#123;u,v,0,q,w&#125;; &#125; dfs(1,0); for(register int i=1;i&lt;=q;++i)&#123; scanf(\"%s\",s+1); if(s[1]=='A')&#123; int u,v;scanf(\"%d%d\",&amp;u,&amp;v);ll w=gl(); e[++tot]=(edge)&#123;u,v,i,q,w&#125;;pos[++id]=tot; &#125; else if(s[2]=='h')&#123; int x;scanf(\"%d\",&amp;x); ll w=gl(); e[pos[x]].r=i-1;e[++tot]=(edge)&#123;e[pos[x]].u,e[pos[x]].v,i,q,w&#125;;pos[x]=tot; &#125; else&#123; int x;scanf(\"%d\",&amp;x); e[pos[x]].r=i-1;pos[x]=-1; &#125; &#125; for(register int i=1;i&lt;=tot;++i) modi(1,0,q,e[i].l,e[i].r,i); query(1,0,q,tmp); return 0;&#125;","raw":"---\ntitle: 解决Xor问题的利器——线性基\ntop: 1\ntags: \n- OI\n- 位运算\n- 线性基\ncategories: \n- 学习笔记\n---\n\n\n位运算是算法竞赛独特而有趣的一类知识，Xor（异或）则是相关题目中出现较为频繁的一种运算。\n\nXor具有以下特点/性质：\n交换律：a^b=b^a\n结合律：a^(b^c)=(a^b)^c\n自零性：a^a=0\n自反性：若a^b=c,则c^b=a,c^a=b\n\n而在Xor一类题目中，我们常常会面对类似这样的问题：求出给定集合产生的所有异或值中最大/k大/最小/k小值。\n\n我们知道，枚举所有子集的异或值复杂度为指数级别，难以处理集合规模较大的问题——不过我们注意到，所有子集产生的异或值会有许多重复的，我们要简化问题的关键就在于如何去重。\n我们就会有这样一个想法——能否构造出一个集合，使其既能保证与原集合异或值域相同，又能大大缩小集合规模呢？\n于是——线性基，应运而生了。\n\n---\n\n### 什么是线性基？\n\n“基”的概念来源于线性代数，线性空间中任意一个元素都可以唯一地表示成基向量的线性组合。\n\n而线性基是一种特殊的基。一个集合的线性基具有如下基本性质：\n- 其子集的异或值域与原集合的异或值域相同\n- 线性基是所有满足第一条性质的集合中最小的集合\n- 线性基无法通过异或得到0\n\n---\n\n### 如何构造线性基？\n\n我们通常用数组p来表示线性基。其中p[i]表示：二进制最高位的1在第i位的数。\n```cpp\n#define ll long long\nconst int N=64;\nll p[N];\ninline void ins(ll x)//向线性基中插入x\n{\n\tfor(int j=63;~j;--j)\n\t{\n        if(x>>j&1)//如果x第j位为1\n\t\t{\n        \tif(!p[j]){p[j]=x;break;}//p[j]尚未存在，那么直接令p[j]=x，不要忘记break\n            else x^=p[j];//否则就让x异或上当前的p[j]，继续\n        }\n    }\n}\n```\n\n考虑这样构造为什么能维护三个基本性质。\n\n- 对于性质一：\n上述方法构造出的线性基之所以能维护性质一，在于该线性基能表示出原集合中的每一个数。\n\n设原集合为x1、x2、x3......xn，现在x1已经被插入线性基，我们插入x2。\n1. 如果x1与x2最高位的1不在同一位上，比如x1=4(100),x2=2(010),由上述构造方法知：x1不会对x2产生影响，x2被顺利插入。\n2. 如果x1与x2最高位的1在同一位上，比如x1=4(100),x2=6(110),那么x2会与x1进行Xor运算。设y=x1^x2,由Xor的自反性知x2=x1^y,那么x2就可以用x1^y表示出来。\n插入x3、x4......xn同理。因此我们可以用一组线性基表示出原集合中的所有数，进而可以得到原集合中的所有异或值。\n\n- 对于性质二：\n这还是非常显然的。\n\n我们在构造线性基时，会不断进行Xor的操作，如果一个数x经过不断Xor后变为0，说明这个数可以由线性基中若干个数表示出来——因为由Xor自零性知，只有当(p[i]^p[j]^p[k]^...^p[w])==x时，x才会变成0。而当且仅当这种情况下x才不会被插入线性基——换句话说，如果一个数被插入了线性基，说明这个数无法用其他数经过Xor得到。\n因此，线性基中的每一个数都无法删去或者合并，因为若被删去或者合并，这个数就没办法表示出来了。所以线性基是满足性质一的最小集合，进而保证了性质二成立。\n\n- 对于性质三：\n前两条性质一旦保证，第三条性质也呼之欲出了。\n\n假设线性基可以通过相互Xor得到0，那么一定有(p[i]^p[j]^...^p[k])==(p[a]^p[b]^...^p[c]),由Xor自反性知，有(p[i]^p[j]^p[k]^p[a]^...^p[b])==p[c]，即p[c]可以用其它的基表示出来，与性质二冲突，假设不成立。\n\n了解了基本性质与构造方法后，我们就可以用线性基去解决一些题目了。至于线性基的一些特殊性质，我们就结合题目来理解吧：\n\n---\n\n### 例题\n\n- [最大异或和](https://loj.ac/problem/113)\n\n线性基模板题。\n\n一个很显然的贪心：我们从高位到低位遍历线性基，若当前ans与当前p[i]进行Xor操作后变大了，我们就令ans=(ans^p[i])。\n贪心正确性？\n对于线性基中每一个p[i]以及任意j<i，一定有p[j]第i位为0——结合构造方法，这个性质不难想到。那么我们每次都尽量保证当前最高位更大，之后在低位一定不会对高位有影响。\n\n```cpp\n#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\n\nconst int N=55;\n\nint n;\nll a[N],p[107];\n\nll read()\n{\n    ll f=1,a=0;char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){a=(a<<3)+(a<<1)+ch-'0';ch=getchar();}\n    return a*f;\n}\n\ninline void Xian_Xing_Ji(ll x) \n{\n    for(register ll i=60;i>=0;--i)\n    {\n        if(!(x>>i))continue;\n        else\n        {\n            if(!p[i]){\n                p[i]=x;\n                break;\n            }\n            else x^=p[i];\n        }\n    }\n}\n\nint main()\n{\n    n=read();\n    for(register int i=1;i<=n;++i)\n    Xian_Xing_Ji(a[i]=read());\n    \n    ll ans=0;\n    \n    for(register int i=60;i>=0;--i)\n    if((ans^p[i])>ans)ans^=p[i];\n    cout<<ans;\n    return 0;\n}\n```\n\n- [k大异或和](https://loj.ac/problem/114)\n\n线性基模板题。不过显然没有上题那么模板化——而且题目叫“k小异或和”似乎妥当一些。\n\n首先我们需要介绍一个特殊性质：线性基中的元素相互Xor，线性基Xor值域不变——比如，设线性基中有元素x,y,现在令x=x^y,那么由Xor的自反性知，原来的x依旧可以用现在的x异或y得到，所以原来线性基的异或集合是不会变的。\n知道这个性质有什么用？本题需要利用这个性质对常规线性基进行改造。\n\n我们令p[i]的意义稍稍改变一下：p[i]表示原Xor集合中，最高位的1在第i位的所有数中最小的一个。例如：若原Xor集合中最高位的1在第3位的有5(101),6(110),那么p[2]就应该等于5。\n接下来，我们要用一个数组a记录非空空的p——比如，p[0]=1,p[1]=0,p[2]=5,我们就要去掉p[1]——因为空的线性基显然不会对答案有贡献，这样就变成了a[0]=1,a[1]=5。\n然后，我们对k进行二进制拆分：若k二进制第i位为1，那么就让当前ans^p[i]，最后的ans就是所求了。\n\n为什么这么做？我们借助一个例子理解一下：\n我们可以用10进制联想：第15小的正整数是谁？十位上第1小的(10)加上各位上第五小的(5)——二进制也同理。若k=5(101)，其实就是要求(非空)第2位上第一小的数Xor上第0位上第一小的数，就是a[2]^a[0]了(想一想，为什么是非空)。\n\n这道题还有两个需要注意的地方：\n1. 怎么求改造后的p[i]？\n从高位到低位遍历原始线性基，对于每一个p[i]，若其第j位(j<i)为1，就让p[i]=p[i]^p[j]。\n如何保证这样得到的p[i]是第i位中最小的？\n这里偷个懒......就不给详细解释了，大家感性理解：这样构造的话我们是让p[i]中比第i位低的1都尽量变成0——我们如何找十进制百位最小的数？显然让是比百位低的位上都为0。二进制也同理，我们要找当前Xor集合中第i位为1的最小数，自然也是尽量让比第i位低的位上都为0啊。\n同时，由前文所述特殊性质知，这样改造出的线性基与原集合Xor集合仍然相同。\n\n2. 由于线性基无法通过Xor得到0，所以若原集合可以通过Xor得到0，那么我们所求原集合中第k小实际上是线性基中的第k-1小。\n怎么判断原集合能否通过Xor得到0？若构造出线性基后发现线性基中的数比原集合中的数少，说明原集合可以通过相互Xor得到0——为什么？若原集合中的数相互Xor能得到0，一定有(x1^x2^...^xn)==0,即(x1^...^x2)==xn,那么由基本性质二可知，xn无法被插入线性基，线性基中数的个数就会比原集合中的数少。\n\n然后我们就可以水过这道题了：\n```cpp\n#include<bits/stdc++.h>\n#define ll long long \nusing namespace std;\nll p[64],a[64],x,k;\nint n,m,cnt=0;\ninline void ins(ll x)\n{\n\tfor(int j=50;~j;--j)\n\t{\n        if(x>>j&1)\n\t\t{\n        \tif(!p[j]){p[j]=x;break;}\n            else x^=p[j];\n        }\n    }\n}\nint main()\n{\n   \n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;++i)\n\t{\n        scanf(\"%lld\",&x);\n        ins(x);\n    }\n    \n    for(int i=50;~i;--i)\n    for(int j=i-1;~j;--j)\n    if(p[i]>>j&1)p[i]^=p[j];\n    \n    for(int i=0;i<=50;++i)\n\tif(p[i])a[cnt++]=p[i];\n\t\n    scanf(\"%d\",&m);\n    \n    while(m--)\n\t{ \t\n        scanf(\"%lld\",&k);\n        if(cnt!=n)--k;\n        if(k>=(1ll<<cnt))puts(\"-1\");\n        else\n\t\t{\n            ll ans=0;\n            for(int i=0;i<cnt;++i)\n                if(k>>i&1)ans^=a[i];\n            printf(\"%lld\\n\",ans);\n        }\n    }\n    return 0;\n}\n```\n\n- [CQOI2013新Nim游戏](https://www.luogu.org/problemnew/show/P4301)\n\n很有意思的一道线性基题目。\n\n我们首先要知道传统Nim游戏如何判断胜负：设火柴堆数分别为x1、x2...xn，那么先手必胜当且仅当x1^x2^...^xn不为0，否则先手必败。具体证明属于博弈论相关，在此不再赘述。\n这道题与传统Nim游戏不一样的地方在于，第一轮双方是可以随便拿整堆火柴的——那么若要先手必胜，先手方必须留下一个局面，使得后手无论怎么做都无法令剩下的所有石子异或为0。\n集合内所有子集Xor值均不为0？一眼线性基！只要先手方留给后手方一个线性基，那不就是先手必胜了吗?\n\n做法就很显然了：对于每一堆火柴，我们判断它是否可以被插入线性基，若可以就插入，否则就把这一堆石子取走。\n有一个需要注意的地方：题目还要求拿走的火柴数目的最小？我们可以贪心：将火柴堆数从大到小排列后进行上述操作。\n为什么是从大到小？我们这么想：我们肯定要先让大的数都尽量插入线性基，这样等到不得不拿走火柴的时候，拿走的就都是小的了。自己举几个例子，相信并不难理解。\n\n```cpp\n#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\n\nconst int N=107;\n\nll p[64],a[N];\nint k;\n\ninline bool ins(ll x){\n    for(register int i=63;~i;--i){\n        if(x>>i&1){\n            if(!p[i]){\n                p[i]=x;\n                return true;\n            } \n            else x^=p[i];\n        }\n    }\n    return false;\n}\n\nll ans;\n\nint main()\n{\n    scanf(\"%d\",&k);\n    for(register int i=1;i<=k;++i)\n    scanf(\"%lld\",&a[i]);\n    \n    sort(a+1,a+k+1);\n    \n    for(register int i=k;i;--i)\n    if(!ins(a[i]))ans+=a[i];\n    \n    cout<<(ll)ans;\n    return 0;\n}\n```\n\n-[albus就是要第一个出场](https://www.luogu.org/problemnew/show/P4869)\n\n又是一道需要用到一个特殊性质的题。\n我们设线性基非空长度为k(如p[0]=1,p[2]=4,p[5]=32,则k=3)，则线性基所能表示的Xor集合里共有2的k次方个不相同的数——这个很显然，每一个基都有选或不选两种可能。而设原集合长度为n，则每一种Xor值都出现了2的n-k次方次。\n这是为什么？我们可以这么考虑：因为原集合的线性基可以表示出所有Xor值，所以除了k个基以外，其它的n-k个数对Xor值并没有贡献，因此我们可以把它们都看成0；与此同时，k个基每产生一个异或值，都可以与这n-k个0继续Xor——从n-k个0中选择若干个零有几种方案呢？2的n-k次方种。\n\n接下来我们要求给定的Q是第几大——我们依旧对线性基进行一个小小改造，我们用一个数组b存储非空p[i]的i(比如p[0]=1,p[1]=0,p[2]=4,则b[0]=0,b[1]=2),如果Q二进制中第b[i]位为1，则对答案贡献为2的i次方——因为说明到第i位时，是有这么多Xor值是比Q小的。\n每种Xor值都出现了2的(n-k)次方次，快速幂在最后处理即可。\n最后答案要+1，因为之前我们求的是有多少Xor值比Q小，加上1才是我们想要的排名。\n```cpp\n#include<bits/stdc++.h>\n#define ll long long\n#define mod 10086\nusing namespace std;\n\nconst int N=2e5+7;\n\nll p[63],a[N],b[N];\nint n,k,tot,sum;\n\ninline void ins(ll x){\n    for(register int i=63;~i;--i){\n        if(x>>i&1){\n            if(!p[i]){\n                p[i]=x;\n                break;\n            }\n            else x^=p[i];\n        }\n    }\n}\n\nll qpow(ll a,ll b){\n    ll ans=1;\n    while(b){\n        if(b&1)ans=(a*ans)%mod;\n        b>>=1;\n        a=(a*a)%mod;\n    }\n    return ans;\n}\n\nint main(){\n    scanf(\"%d\",&n);\n    for(register int i=1;i<=n;++i)scanf(\"%lld\",&a[i]),ins(a[i]);\n    scanf(\"%d\",&k);\n    for(register int i=0;i<64;++i)\n    if(p[i])b[tot++]=i;\n    for(register int i=0;i<tot;++i)\n    if(k>>b[i]&1)sum+=1ll<<i;\n        \n    cout<<(1ll*sum*qpow(2,n-tot)+1)%mod;\n    return 0;\n} \n```\n\n- [【WC2011】最大Xor和路径](https://www.luogu.org/problemnew/show/P4151)\n\n非常经典的题目。可以说是图上线性基的板子题。\n\n我们考虑：从1号点到n号点的路径，可以划分成一些简单路径和环：\n![例图1](http://i1.fuimg.com/683055/eb3b7062150a173d.png)\n上图是一个最简单的例子，图中1-2-3-9是一条简单路径，而2-7-8、5-4-6构成两个环。\n而如果我们走进了一个环，那么要么把一整个环从头到尾遍历一遍，这样做环上所有路径的权值都会对Xor和产生贡献；要么我们走一半掉头回去——由Xor的自反性可知，之前经过的环上路径权值都又被消掉了，对答案没有贡献。\n于是我们得到了一个结论：对于一个环，它对答案的贡献只能是环上所有路径的Xor和（选了这个环）或者为0（不选这个环）。\n那么我们就有了一个思路——如果从1到n只有一条简单路径，那么我们显然必须走这条路，同时我们可以在途中经过一些环来更新答案。于是问题变成了：给你一个初始值（简单路径Xor和），再给你一些数（所有环各自的Xor和），让你求从这些数中选出若干后与初始值的最大Xor和值——这不就成了线性基模板题吗？我们先求出1到n的简单路径Xor和，再dfs出所有环各自的Xor和，把这些环上Xor和丢进线性基，以1到n的简单路径Xor和为初始值做一遍最大异或和即可。\n那如果1到n有多条简单路径呢？\n![例图2](http://i1.fuimg.com/683055/2fe430e3dcfed57c.png)\n其实是一样的！我们一开始任意选择一条简单路径后，按照上述做法做一遍就好。\n为什么可以随意选择初始的简单路径？\n很明显，如果从1到n有多条简单路径，那么它们相互构成了一个大环。以上图为例，图中有3-4-5、1-2-7-6两个环，从1到n的简单路径有1-2-7、1-6-7两条。假设我们一开始选择了1-2-7这条路并不是最优的，那么在按照最大异或和的做法进行的时候，它就会被1-2-7-6这个大环Xor掉，由Xor自反性可知，这相当于我们一开始选择了更优的1-6-7这条路径，依然可以保证答案的正确性。\n于是对于这一类题目我们就有了做法：把所有环上Xor和扔进线性基，随便拎出来一条简单路径当初始值，跑一遍最大Xor和即可。\n```cpp\n#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\n\nconst int N=3e7+9;\n\nstruct nod{\n    int nx,to;\n    ll va;\n}a[N];\n\nll p[N],dis[N];\nint vis[N],head[N],tot,n,m;\n\ninline void add(int fr,int to,ll va){a[++tot].to=to;a[tot].nx=head[fr];a[tot].va=va;head[fr]=tot;}\n\ninline void ins(ll x){\n    for(register int i=63;i>=0;--i){\n        if((x>>i)&1){\n            if(!p[i]){\n                p[i]=x;\n                break;\n            }\n            x^=p[i];\n        }\n    }\n}\n\nvoid dfs(int x,ll res)\n{\n    vis[x]=1;dis[x]=res;\n    for(register int i=head[x];i;i=a[i].nx)\n        if(!vis[a[i].to])dfs(a[i].to,res^a[i].va);\n        else ins(res^dis[a[i].to]^a[i].va);\n    \n}\n\ninline ll que(ll x){\n    ll res=x;\n    for(register int i=63;i>=0;--i)\n    if((res^p[i])>res)res^=p[i];\n    return res;\n}\n\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    for(register int i=1;i<=m;++i)\n    {\n        int x,y;ll v;\n        scanf(\"%d%d%lld\",&x,&y,&v);\n        add(x,y,v);add(y,x,v);\n    }\n    dfs(1,0);\n    printf(\"%lld\",que(dis[n]));\n    return 0;\n}\n```\n- [【HAOI2017】八纵八横](https://www.luogu.org/problemnew/show/P3733)\n\n~~HAOI为什么考板子题啊~~\n其实相较上一题这道题还是难度更大的。原因在于：这道题中要求有删除和修改操作，可传统线性基并不支持删除与修改。\n首先，我们可以转换思路：把修改后的边看成一条新出现的边，修改前的边就当把它删掉了——这样以来我们就只用考虑如何处理删除操作。\n避开删除，只进行插入？我们想到了线段树分治！\n以时间为轴，存储每条道路出现的时间区间，每次把一个时间段内存在的道路插入线性基，到了某一个具体时刻直接输出即可。\n```cpp\n#include<bits/stdc++.h>\n#define N 1005\n#define mid ((l+r)>>1)\n#define ll bitset<N>\nusing namespace std;\n\nint n,m,q;\nchar s[N];\n\nint to[N],nxt[N],head[N],cnt;\nll ww[N],dis[N];\nint pos[N],id,tot,fa[N];\nvector<int>v[N<<3];\nstruct edge{\n    int u,v,l,r;\n    ll w;\n}e[N<<4]; \n\nvoid link(int u,int v,ll w){\n    to[++cnt]=v;nxt[cnt]=head[u];ww[cnt]=w;head[u]=cnt;\n    to[++cnt]=u;nxt[cnt]=head[v];ww[cnt]=w;head[v]=cnt;\n}\n\nint find(int x){return x==fa[x]?x:fa[x]=find(fa[x]);}\n\nll gl(){scanf(\"%s\",s+1);int len=strlen(s+1);ll x;x.reset();for(register int i=1;i<=len;++i)x[len-i]=s[i]-'0';return x;}\n\nstruct xxj{\n    ll p[N];\n    void ins(ll x){\n        for(register int i=N-1;~i;--i)\n        if(x[i]){\n            if(!p[i].any()){p[i]=x;return;}\n            x^=p[i];\n        }\n    }\n    ll cal(){\n        ll x;x.reset();\n        for(register int i=N-1;~i;--i)\n        if(!x[i])x^=p[i];\n        return x;\n    }\n}tmp;\n\nvoid print(ll x){\n    int i=N-1;while (!x[i]) --i;\n    while (~i) putchar(x[i]+'0'),--i;puts(\"\");\n}\n\nvoid dfs(int u,int f)\n{\n    for(register int i=head[u];~i;i=nxt[i])\n    {\n        int v=to[i];\n        if(v==f)continue;\n        dis[v]=dis[u]^ww[i];\n        dfs(v,u);\n    }\n}\n\nvoid modi(int x,int l,int r,int ql,int qr,int i){\n    if(l>=ql&&r<=qr){v[x].push_back(i);return;}\n    if(ql<=mid)modi(x<<1,l,mid,ql,qr,i);\n    if(qr>mid)modi(x<<1|1,mid+1,r,ql,qr,i);\n}\n\nvoid query(int x,int l,int r,xxj S)\n{\n    int len=v[x].size();\n    for(register int i=0;i<len;++i)\n    S.ins(dis[e[v[x][i]].u]^dis[e[v[x][i]].v]^e[v[x][i]].w);\n    if(l==r){print(S.cal());return;}\n    query(x<<1,l,mid,S);query(x<<1|1,mid+1,r,S);\n}\n\nint main(){\n    memset(head,-1,sizeof(head));\n    \n    scanf(\"%d%d%d\",&n,&m,&q);\n    for(register int i=1;i<=n;++i)fa[i]=i;\n    for(register int i=1;i<=m;++i)\n    {\n        int u,v;\n        scanf(\"%d%d\",&u,&v);\n        ll w=gl();\n        if(find(u)!=find(v))link(u,v,w),fa[find(u)]=find(v);\n        else e[++tot]=(edge){u,v,0,q,w};\n    }\n    dfs(1,0);\n    for(register int i=1;i<=q;++i){\n        scanf(\"%s\",s+1);\n        if(s[1]=='A'){\n            int u,v;scanf(\"%d%d\",&u,&v);ll w=gl();\n            e[++tot]=(edge){u,v,i,q,w};pos[++id]=tot;\n        }\n        else if(s[2]=='h'){\n            int x;scanf(\"%d\",&x);\n            ll w=gl();\n            e[pos[x]].r=i-1;e[++tot]=(edge){e[pos[x]].u,e[pos[x]].v,i,q,w};pos[x]=tot;\n        }\n        else{\n            int x;scanf(\"%d\",&x);\n            e[pos[x]].r=i-1;pos[x]=-1;\n        }\n    }\n    for(register int i=1;i<=tot;++i)\n    modi(1,0,q,e[i].l,e[i].r,i);\n    \n    query(1,0,q,tmp);\n    return 0;\n}\n```","content":"<p>位运算是算法竞赛独特而有趣的一类知识，Xor（异或）则是相关题目中出现较为频繁的一种运算。</p>\n<p>Xor具有以下特点/性质：<br>交换律：a^b=b^a<br>结合律：a^(b^c)=(a^b)^c<br>自零性：a^a=0<br>自反性：若a^b=c,则c^b=a,c^a=b</p>\n<p>而在Xor一类题目中，我们常常会面对类似这样的问题：求出给定集合产生的所有异或值中最大/k大/最小/k小值。</p>\n<p>我们知道，枚举所有子集的异或值复杂度为指数级别，难以处理集合规模较大的问题——不过我们注意到，所有子集产生的异或值会有许多重复的，我们要简化问题的关键就在于如何去重。<br>我们就会有这样一个想法——能否构造出一个集合，使其既能保证与原集合异或值域相同，又能大大缩小集合规模呢？<br>于是——线性基，应运而生了。</p>\n<hr>\n<h3 id=\"什么是线性基？\"><a href=\"#什么是线性基？\" class=\"headerlink\" title=\"什么是线性基？\"></a>什么是线性基？</h3><p>“基”的概念来源于线性代数，线性空间中任意一个元素都可以唯一地表示成基向量的线性组合。</p>\n<p>而线性基是一种特殊的基。一个集合的线性基具有如下基本性质：</p>\n<ul>\n<li>其子集的异或值域与原集合的异或值域相同</li>\n<li>线性基是所有满足第一条性质的集合中最小的集合</li>\n<li>线性基无法通过异或得到0</li>\n</ul>\n<hr>\n<h3 id=\"如何构造线性基？\"><a href=\"#如何构造线性基？\" class=\"headerlink\" title=\"如何构造线性基？\"></a>如何构造线性基？</h3><p>我们通常用数组p来表示线性基。其中p[i]表示：二进制最高位的1在第i位的数。<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ll long long</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> N=<span class=\"number\">64</span>;</span><br><span class=\"line\">ll p[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">ins</span><span class=\"params\">(ll x)</span><span class=\"comment\">//向线性基中插入x</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">63</span>;~j;--j)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(x&gt;&gt;j&amp;<span class=\"number\">1</span>)<span class=\"comment\">//如果x第j位为1</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">        \t<span class=\"keyword\">if</span>(!p[j])&#123;p[j]=x;<span class=\"keyword\">break</span>;&#125;<span class=\"comment\">//p[j]尚未存在，那么直接令p[j]=x，不要忘记break</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> x^=p[j];<span class=\"comment\">//否则就让x异或上当前的p[j]，继续</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>考虑这样构造为什么能维护三个基本性质。</p>\n<ul>\n<li>对于性质一：<br>上述方法构造出的线性基之所以能维护性质一，在于该线性基能表示出原集合中的每一个数。</li>\n</ul>\n<p>设原集合为x1、x2、x3……xn，现在x1已经被插入线性基，我们插入x2。</p>\n<ol>\n<li>如果x1与x2最高位的1不在同一位上，比如x1=4(100),x2=2(010),由上述构造方法知：x1不会对x2产生影响，x2被顺利插入。</li>\n<li>如果x1与x2最高位的1在同一位上，比如x1=4(100),x2=6(110),那么x2会与x1进行Xor运算。设y=x1^x2,由Xor的自反性知x2=x1^y,那么x2就可以用x1^y表示出来。<br>插入x3、x4……xn同理。因此我们可以用一组线性基表示出原集合中的所有数，进而可以得到原集合中的所有异或值。</li>\n</ol>\n<ul>\n<li>对于性质二：<br>这还是非常显然的。</li>\n</ul>\n<p>我们在构造线性基时，会不断进行Xor的操作，如果一个数x经过不断Xor后变为0，说明这个数可以由线性基中若干个数表示出来——因为由Xor自零性知，只有当(p[i]^p[j]^p[k]^…^p[w])==x时，x才会变成0。而当且仅当这种情况下x才不会被插入线性基——换句话说，如果一个数被插入了线性基，说明这个数无法用其他数经过Xor得到。<br>因此，线性基中的每一个数都无法删去或者合并，因为若被删去或者合并，这个数就没办法表示出来了。所以线性基是满足性质一的最小集合，进而保证了性质二成立。</p>\n<ul>\n<li>对于性质三：<br>前两条性质一旦保证，第三条性质也呼之欲出了。</li>\n</ul>\n<p>假设线性基可以通过相互Xor得到0，那么一定有(p[i]^p[j]^…^p[k])==(p[a]^p[b]^…^p[c]),由Xor自反性知，有(p[i]^p[j]^p[k]^p[a]^…^p[b])==p[c]，即p[c]可以用其它的基表示出来，与性质二冲突，假设不成立。</p>\n<p>了解了基本性质与构造方法后，我们就可以用线性基去解决一些题目了。至于线性基的一些特殊性质，我们就结合题目来理解吧：</p>\n<hr>\n<h3 id=\"例题\"><a href=\"#例题\" class=\"headerlink\" title=\"例题\"></a>例题</h3><ul>\n<li><a href=\"https://loj.ac/problem/113\" target=\"_blank\" rel=\"noopener\">最大异或和</a></li>\n</ul>\n<p>线性基模板题。</p>\n<p>一个很显然的贪心：我们从高位到低位遍历线性基，若当前ans与当前p[i]进行Xor操作后变大了，我们就令ans=(ans^p[i])。<br>贪心正确性？<br>对于线性基中每一个p[i]以及任意j&lt;i，一定有p[j]第i位为0——结合构造方法，这个性质不难想到。那么我们每次都尽量保证当前最高位更大，之后在低位一定不会对高位有影响。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ll long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> N=<span class=\"number\">55</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> n;</span><br><span class=\"line\">ll a[N],p[<span class=\"number\">107</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">read</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    ll f=<span class=\"number\">1</span>,a=<span class=\"number\">0</span>;<span class=\"keyword\">char</span> ch=getchar();</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(ch&lt;<span class=\"string\">'0'</span>||ch&gt;<span class=\"string\">'9'</span>)&#123;<span class=\"keyword\">if</span>(ch==<span class=\"string\">'-'</span>)f=<span class=\"number\">-1</span>;ch=getchar();&#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(ch&gt;=<span class=\"string\">'0'</span>&amp;&amp;ch&lt;=<span class=\"string\">'9'</span>)&#123;a=(a&lt;&lt;<span class=\"number\">3</span>)+(a&lt;&lt;<span class=\"number\">1</span>)+ch-<span class=\"string\">'0'</span>;ch=getchar();&#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a*f;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">Xian_Xing_Ji</span><span class=\"params\">(ll x)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">register</span> ll i=<span class=\"number\">60</span>;i&gt;=<span class=\"number\">0</span>;--i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!(x&gt;&gt;i))<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!p[i])&#123;</span><br><span class=\"line\">                p[i]=x;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> x^=p[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    n=read();</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">register</span> <span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;++i)</span><br><span class=\"line\">    Xian_Xing_Ji(a[i]=read());</span><br><span class=\"line\">    </span><br><span class=\"line\">    ll ans=<span class=\"number\">0</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">register</span> <span class=\"keyword\">int</span> i=<span class=\"number\">60</span>;i&gt;=<span class=\"number\">0</span>;--i)</span><br><span class=\"line\">    <span class=\"keyword\">if</span>((ans^p[i])&gt;ans)ans^=p[i];</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;ans;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><a href=\"https://loj.ac/problem/114\" target=\"_blank\" rel=\"noopener\">k大异或和</a></li>\n</ul>\n<p>线性基模板题。不过显然没有上题那么模板化——而且题目叫“k小异或和”似乎妥当一些。</p>\n<p>首先我们需要介绍一个特殊性质：线性基中的元素相互Xor，线性基Xor值域不变——比如，设线性基中有元素x,y,现在令x=x^y,那么由Xor的自反性知，原来的x依旧可以用现在的x异或y得到，所以原来线性基的异或集合是不会变的。<br>知道这个性质有什么用？本题需要利用这个性质对常规线性基进行改造。</p>\n<p>我们令p[i]的意义稍稍改变一下：p[i]表示原Xor集合中，最高位的1在第i位的所有数中最小的一个。例如：若原Xor集合中最高位的1在第3位的有5(101),6(110),那么p[2]就应该等于5。<br>接下来，我们要用一个数组a记录非空空的p——比如，p[0]=1,p[1]=0,p[2]=5,我们就要去掉p[1]——因为空的线性基显然不会对答案有贡献，这样就变成了a[0]=1,a[1]=5。<br>然后，我们对k进行二进制拆分：若k二进制第i位为1，那么就让当前ans^p[i]，最后的ans就是所求了。</p>\n<p>为什么这么做？我们借助一个例子理解一下：<br>我们可以用10进制联想：第15小的正整数是谁？十位上第1小的(10)加上各位上第五小的(5)——二进制也同理。若k=5(101)，其实就是要求(非空)第2位上第一小的数Xor上第0位上第一小的数，就是a[2]^a[0]了(想一想，为什么是非空)。</p>\n<p>这道题还有两个需要注意的地方：</p>\n<ol>\n<li><p>怎么求改造后的p[i]？<br>从高位到低位遍历原始线性基，对于每一个p[i]，若其第j位(j&lt;i)为1，就让p[i]=p[i]^p[j]。<br>如何保证这样得到的p[i]是第i位中最小的？<br>这里偷个懒……就不给详细解释了，大家感性理解：这样构造的话我们是让p[i]中比第i位低的1都尽量变成0——我们如何找十进制百位最小的数？显然让是比百位低的位上都为0。二进制也同理，我们要找当前Xor集合中第i位为1的最小数，自然也是尽量让比第i位低的位上都为0啊。<br>同时，由前文所述特殊性质知，这样改造出的线性基与原集合Xor集合仍然相同。</p>\n</li>\n<li><p>由于线性基无法通过Xor得到0，所以若原集合可以通过Xor得到0，那么我们所求原集合中第k小实际上是线性基中的第k-1小。<br>怎么判断原集合能否通过Xor得到0？若构造出线性基后发现线性基中的数比原集合中的数少，说明原集合可以通过相互Xor得到0——为什么？若原集合中的数相互Xor能得到0，一定有(x1^x2^…^xn)==0,即(x1^…^x2)==xn,那么由基本性质二可知，xn无法被插入线性基，线性基中数的个数就会比原集合中的数少。</p>\n</li>\n</ol>\n<p>然后我们就可以水过这道题了：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ll long long </span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\">ll p[<span class=\"number\">64</span>],a[<span class=\"number\">64</span>],x,k;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n,m,cnt=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">ins</span><span class=\"params\">(ll x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">50</span>;~j;--j)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(x&gt;&gt;j&amp;<span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">        \t<span class=\"keyword\">if</span>(!p[j])&#123;p[j]=x;<span class=\"keyword\">break</span>;&#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> x^=p[j];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;n);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;++i)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%lld\"</span>,&amp;x);</span><br><span class=\"line\">        ins(x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">50</span>;~i;--i)</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=i<span class=\"number\">-1</span>;~j;--j)</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(p[i]&gt;&gt;j&amp;<span class=\"number\">1</span>)p[i]^=p[j];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;=<span class=\"number\">50</span>;++i)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(p[i])a[cnt++]=p[i];</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;m);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">while</span>(m--)</span><br><span class=\"line\">\t&#123; \t</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%lld\"</span>,&amp;k);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(cnt!=n)--k;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(k&gt;=(<span class=\"number\">1l</span>l&lt;&lt;cnt))<span class=\"built_in\">puts</span>(<span class=\"string\">\"-1\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">            ll ans=<span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;cnt;++i)</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(k&gt;&gt;i&amp;<span class=\"number\">1</span>)ans^=a[i];</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%lld\\n\"</span>,ans);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><a href=\"https://www.luogu.org/problemnew/show/P4301\" target=\"_blank\" rel=\"noopener\">CQOI2013新Nim游戏</a></li>\n</ul>\n<p>很有意思的一道线性基题目。</p>\n<p>我们首先要知道传统Nim游戏如何判断胜负：设火柴堆数分别为x1、x2…xn，那么先手必胜当且仅当x1^x2^…^xn不为0，否则先手必败。具体证明属于博弈论相关，在此不再赘述。<br>这道题与传统Nim游戏不一样的地方在于，第一轮双方是可以随便拿整堆火柴的——那么若要先手必胜，先手方必须留下一个局面，使得后手无论怎么做都无法令剩下的所有石子异或为0。<br>集合内所有子集Xor值均不为0？一眼线性基！只要先手方留给后手方一个线性基，那不就是先手必胜了吗?</p>\n<p>做法就很显然了：对于每一堆火柴，我们判断它是否可以被插入线性基，若可以就插入，否则就把这一堆石子取走。<br>有一个需要注意的地方：题目还要求拿走的火柴数目的最小？我们可以贪心：将火柴堆数从大到小排列后进行上述操作。<br>为什么是从大到小？我们这么想：我们肯定要先让大的数都尽量插入线性基，这样等到不得不拿走火柴的时候，拿走的就都是小的了。自己举几个例子，相信并不难理解。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ll long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> N=<span class=\"number\">107</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">ll p[<span class=\"number\">64</span>],a[N];</span><br><span class=\"line\"><span class=\"keyword\">int</span> k;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"title\">ins</span><span class=\"params\">(ll x)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">register</span> <span class=\"keyword\">int</span> i=<span class=\"number\">63</span>;~i;--i)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(x&gt;&gt;i&amp;<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!p[i])&#123;</span><br><span class=\"line\">                p[i]=x;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125; </span><br><span class=\"line\">            <span class=\"keyword\">else</span> x^=p[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ll ans;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;k);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">register</span> <span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=k;++i)</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%lld\"</span>,&amp;a[i]);</span><br><span class=\"line\">    </span><br><span class=\"line\">    sort(a+<span class=\"number\">1</span>,a+k+<span class=\"number\">1</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">register</span> <span class=\"keyword\">int</span> i=k;i;--i)</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!ins(a[i]))ans+=a[i];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;(ll)ans;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>-<a href=\"https://www.luogu.org/problemnew/show/P4869\" target=\"_blank\" rel=\"noopener\">albus就是要第一个出场</a></p>\n<p>又是一道需要用到一个特殊性质的题。<br>我们设线性基非空长度为k(如p[0]=1,p[2]=4,p[5]=32,则k=3)，则线性基所能表示的Xor集合里共有2的k次方个不相同的数——这个很显然，每一个基都有选或不选两种可能。而设原集合长度为n，则每一种Xor值都出现了2的n-k次方次。<br>这是为什么？我们可以这么考虑：因为原集合的线性基可以表示出所有Xor值，所以除了k个基以外，其它的n-k个数对Xor值并没有贡献，因此我们可以把它们都看成0；与此同时，k个基每产生一个异或值，都可以与这n-k个0继续Xor——从n-k个0中选择若干个零有几种方案呢？2的n-k次方种。</p>\n<p>接下来我们要求给定的Q是第几大——我们依旧对线性基进行一个小小改造，我们用一个数组b存储非空p[i]的i(比如p[0]=1,p[1]=0,p[2]=4,则b[0]=0,b[1]=2),如果Q二进制中第b[i]位为1，则对答案贡献为2的i次方——因为说明到第i位时，是有这么多Xor值是比Q小的。<br>每种Xor值都出现了2的(n-k)次方次，快速幂在最后处理即可。<br>最后答案要+1，因为之前我们求的是有多少Xor值比Q小，加上1才是我们想要的排名。<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ll long long</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> mod 10086</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> N=<span class=\"number\">2e5</span>+<span class=\"number\">7</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">ll p[<span class=\"number\">63</span>],a[N],b[N];</span><br><span class=\"line\"><span class=\"keyword\">int</span> n,k,tot,sum;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">ins</span><span class=\"params\">(ll x)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">register</span> <span class=\"keyword\">int</span> i=<span class=\"number\">63</span>;~i;--i)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(x&gt;&gt;i&amp;<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!p[i])&#123;</span><br><span class=\"line\">                p[i]=x;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> x^=p[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">qpow</span><span class=\"params\">(ll a,ll b)</span></span>&#123;</span><br><span class=\"line\">    ll ans=<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(b)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(b&amp;<span class=\"number\">1</span>)ans=(a*ans)%mod;</span><br><span class=\"line\">        b&gt;&gt;=<span class=\"number\">1</span>;</span><br><span class=\"line\">        a=(a*a)%mod;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;n);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">register</span> <span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;++i)<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%lld\"</span>,&amp;a[i]),ins(a[i]);</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;k);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">register</span> <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">64</span>;++i)</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(p[i])b[tot++]=i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">register</span> <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;tot;++i)</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(k&gt;&gt;b[i]&amp;<span class=\"number\">1</span>)sum+=<span class=\"number\">1l</span>l&lt;&lt;i;</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;(<span class=\"number\">1l</span>l*sum*qpow(<span class=\"number\">2</span>,n-tot)+<span class=\"number\">1</span>)%mod;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><a href=\"https://www.luogu.org/problemnew/show/P4151\" target=\"_blank\" rel=\"noopener\">【WC2011】最大Xor和路径</a></li>\n</ul>\n<p>非常经典的题目。可以说是图上线性基的板子题。</p>\n<p>我们考虑：从1号点到n号点的路径，可以划分成一些简单路径和环：<br><img src=\"http://i1.fuimg.com/683055/eb3b7062150a173d.png\" alt=\"例图1\"><br>上图是一个最简单的例子，图中1-2-3-9是一条简单路径，而2-7-8、5-4-6构成两个环。<br>而如果我们走进了一个环，那么要么把一整个环从头到尾遍历一遍，这样做环上所有路径的权值都会对Xor和产生贡献；要么我们走一半掉头回去——由Xor的自反性可知，之前经过的环上路径权值都又被消掉了，对答案没有贡献。<br>于是我们得到了一个结论：对于一个环，它对答案的贡献只能是环上所有路径的Xor和（选了这个环）或者为0（不选这个环）。<br>那么我们就有了一个思路——如果从1到n只有一条简单路径，那么我们显然必须走这条路，同时我们可以在途中经过一些环来更新答案。于是问题变成了：给你一个初始值（简单路径Xor和），再给你一些数（所有环各自的Xor和），让你求从这些数中选出若干后与初始值的最大Xor和值——这不就成了线性基模板题吗？我们先求出1到n的简单路径Xor和，再dfs出所有环各自的Xor和，把这些环上Xor和丢进线性基，以1到n的简单路径Xor和为初始值做一遍最大异或和即可。<br>那如果1到n有多条简单路径呢？<br><img src=\"http://i1.fuimg.com/683055/2fe430e3dcfed57c.png\" alt=\"例图2\"><br>其实是一样的！我们一开始任意选择一条简单路径后，按照上述做法做一遍就好。<br>为什么可以随意选择初始的简单路径？<br>很明显，如果从1到n有多条简单路径，那么它们相互构成了一个大环。以上图为例，图中有3-4-5、1-2-7-6两个环，从1到n的简单路径有1-2-7、1-6-7两条。假设我们一开始选择了1-2-7这条路并不是最优的，那么在按照最大异或和的做法进行的时候，它就会被1-2-7-6这个大环Xor掉，由Xor自反性可知，这相当于我们一开始选择了更优的1-6-7这条路径，依然可以保证答案的正确性。<br>于是对于这一类题目我们就有了做法：把所有环上Xor和扔进线性基，随便拎出来一条简单路径当初始值，跑一遍最大Xor和即可。<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ll long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> N=<span class=\"number\">3e7</span>+<span class=\"number\">9</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">nod</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> nx,to;</span><br><span class=\"line\">    ll va;</span><br><span class=\"line\">&#125;a[N];</span><br><span class=\"line\"></span><br><span class=\"line\">ll p[N],dis[N];</span><br><span class=\"line\"><span class=\"keyword\">int</span> vis[N],head[N],tot,n,m;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> fr,<span class=\"keyword\">int</span> to,ll va)</span></span>&#123;a[++tot].to=to;a[tot].nx=head[fr];a[tot].va=va;head[fr]=tot;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">ins</span><span class=\"params\">(ll x)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">register</span> <span class=\"keyword\">int</span> i=<span class=\"number\">63</span>;i&gt;=<span class=\"number\">0</span>;--i)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>((x&gt;&gt;i)&amp;<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!p[i])&#123;</span><br><span class=\"line\">                p[i]=x;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            x^=p[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> x,ll res)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    vis[x]=<span class=\"number\">1</span>;dis[x]=res;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">register</span> <span class=\"keyword\">int</span> i=head[x];i;i=a[i].nx)</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!vis[a[i].to])dfs(a[i].to,res^a[i].va);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> ins(res^dis[a[i].to]^a[i].va);</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> ll <span class=\"title\">que</span><span class=\"params\">(ll x)</span></span>&#123;</span><br><span class=\"line\">    ll res=x;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">register</span> <span class=\"keyword\">int</span> i=<span class=\"number\">63</span>;i&gt;=<span class=\"number\">0</span>;--i)</span><br><span class=\"line\">    <span class=\"keyword\">if</span>((res^p[i])&gt;res)res^=p[i];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>,&amp;n,&amp;m);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">register</span> <span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> x,y;ll v;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d%lld\"</span>,&amp;x,&amp;y,&amp;v);</span><br><span class=\"line\">        add(x,y,v);add(y,x,v);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dfs(<span class=\"number\">1</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%lld\"</span>,que(dis[n]));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><a href=\"https://www.luogu.org/problemnew/show/P3733\" target=\"_blank\" rel=\"noopener\">【HAOI2017】八纵八横</a></li>\n</ul>\n<p><del>HAOI为什么考板子题啊</del><br>其实相较上一题这道题还是难度更大的。原因在于：这道题中要求有删除和修改操作，可传统线性基并不支持删除与修改。<br>首先，我们可以转换思路：把修改后的边看成一条新出现的边，修改前的边就当把它删掉了——这样以来我们就只用考虑如何处理删除操作。<br>避开删除，只进行插入？我们想到了线段树分治！<br>以时间为轴，存储每条道路出现的时间区间，每次把一个时间段内存在的道路插入线性基，到了某一个具体时刻直接输出即可。<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N 1005</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> mid ((l+r)&gt;&gt;1)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ll bitset<span class=\"meta-string\">&lt;N&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> n,m,q;</span><br><span class=\"line\"><span class=\"keyword\">char</span> s[N];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> to[N],nxt[N],head[N],cnt;</span><br><span class=\"line\">ll ww[N],dis[N];</span><br><span class=\"line\"><span class=\"keyword\">int</span> pos[N],id,tot,fa[N];</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;v[N&lt;&lt;<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">edge</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> u,v,l,r;</span><br><span class=\"line\">    ll w;</span><br><span class=\"line\">&#125;e[N&lt;&lt;<span class=\"number\">4</span>]; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">link</span><span class=\"params\">(<span class=\"keyword\">int</span> u,<span class=\"keyword\">int</span> v,ll w)</span></span>&#123;</span><br><span class=\"line\">    to[++cnt]=v;nxt[cnt]=head[u];ww[cnt]=w;head[u]=cnt;</span><br><span class=\"line\">    to[++cnt]=u;nxt[cnt]=head[v];ww[cnt]=w;head[v]=cnt;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>&#123;<span class=\"keyword\">return</span> x==fa[x]?x:fa[x]=find(fa[x]);&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">gl</span><span class=\"params\">()</span></span>&#123;<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>,s+<span class=\"number\">1</span>);<span class=\"keyword\">int</span> len=<span class=\"built_in\">strlen</span>(s+<span class=\"number\">1</span>);ll x;x.reset();<span class=\"keyword\">for</span>(<span class=\"keyword\">register</span> <span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=len;++i)x[len-i]=s[i]-<span class=\"string\">'0'</span>;<span class=\"keyword\">return</span> x;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">xxj</span>&#123;</span></span><br><span class=\"line\">    ll p[N];</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ins</span><span class=\"params\">(ll x)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">register</span> <span class=\"keyword\">int</span> i=N<span class=\"number\">-1</span>;~i;--i)</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(x[i])&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!p[i].any())&#123;p[i]=x;<span class=\"keyword\">return</span>;&#125;</span><br><span class=\"line\">            x^=p[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\">ll <span class=\"title\">cal</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        ll x;x.reset();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">register</span> <span class=\"keyword\">int</span> i=N<span class=\"number\">-1</span>;~i;--i)</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!x[i])x^=p[i];</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;tmp;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(ll x)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i=N<span class=\"number\">-1</span>;<span class=\"keyword\">while</span> (!x[i]) --i;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (~i) <span class=\"built_in\">putchar</span>(x[i]+<span class=\"string\">'0'</span>),--i;<span class=\"built_in\">puts</span>(<span class=\"string\">\"\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> u,<span class=\"keyword\">int</span> f)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">register</span> <span class=\"keyword\">int</span> i=head[u];~i;i=nxt[i])</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> v=to[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(v==f)<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        dis[v]=dis[u]^ww[i];</span><br><span class=\"line\">        dfs(v,u);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">modi</span><span class=\"params\">(<span class=\"keyword\">int</span> x,<span class=\"keyword\">int</span> l,<span class=\"keyword\">int</span> r,<span class=\"keyword\">int</span> ql,<span class=\"keyword\">int</span> qr,<span class=\"keyword\">int</span> i)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l&gt;=ql&amp;&amp;r&lt;=qr)&#123;v[x].push_back(i);<span class=\"keyword\">return</span>;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(ql&lt;=mid)modi(x&lt;&lt;<span class=\"number\">1</span>,l,mid,ql,qr,i);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(qr&gt;mid)modi(x&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,mid+<span class=\"number\">1</span>,r,ql,qr,i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">int</span> x,<span class=\"keyword\">int</span> l,<span class=\"keyword\">int</span> r,xxj S)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len=v[x].size();</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">register</span> <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;len;++i)</span><br><span class=\"line\">    S.ins(dis[e[v[x][i]].u]^dis[e[v[x][i]].v]^e[v[x][i]].w);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l==r)&#123;print(S.cal());<span class=\"keyword\">return</span>;&#125;</span><br><span class=\"line\">    query(x&lt;&lt;<span class=\"number\">1</span>,l,mid,S);query(x&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,mid+<span class=\"number\">1</span>,r,S);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(head,<span class=\"number\">-1</span>,<span class=\"keyword\">sizeof</span>(head));</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d%d\"</span>,&amp;n,&amp;m,&amp;q);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">register</span> <span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;++i)fa[i]=i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">register</span> <span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> u,v;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>,&amp;u,&amp;v);</span><br><span class=\"line\">        ll w=gl();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(find(u)!=find(v))link(u,v,w),fa[find(u)]=find(v);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> e[++tot]=(edge)&#123;u,v,<span class=\"number\">0</span>,q,w&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dfs(<span class=\"number\">1</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">register</span> <span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=q;++i)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>,s+<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s[<span class=\"number\">1</span>]==<span class=\"string\">'A'</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> u,v;<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>,&amp;u,&amp;v);ll w=gl();</span><br><span class=\"line\">            e[++tot]=(edge)&#123;u,v,i,q,w&#125;;pos[++id]=tot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(s[<span class=\"number\">2</span>]==<span class=\"string\">'h'</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> x;<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;x);</span><br><span class=\"line\">            ll w=gl();</span><br><span class=\"line\">            e[pos[x]].r=i<span class=\"number\">-1</span>;e[++tot]=(edge)&#123;e[pos[x]].u,e[pos[x]].v,i,q,w&#125;;pos[x]=tot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> x;<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;x);</span><br><span class=\"line\">            e[pos[x]].r=i<span class=\"number\">-1</span>;pos[x]=<span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">register</span> <span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=tot;++i)</span><br><span class=\"line\">    modi(<span class=\"number\">1</span>,<span class=\"number\">0</span>,q,e[i].l,e[i].r,i);</span><br><span class=\"line\">    </span><br><span class=\"line\">    query(<span class=\"number\">1</span>,<span class=\"number\">0</span>,q,tmp);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","slug":"线性基随笔","updated":"2019-04-09T01:36:31.564Z","link":"","permalink":"https://micardi.github.io/2019/03/29/线性基随笔/","excerpt":"","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://micardi.github.io/categories/学习笔记/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://micardi.github.io/tags/OI/"},{"name":"位运算","slug":"位运算","permalink":"https://micardi.github.io/tags/位运算/"},{"name":"线性基","slug":"线性基","permalink":"https://micardi.github.io/tags/线性基/"}]}]}