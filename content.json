{"meta":{"title":"Micardi","subtitle":null,"description":null,"author":"Micardi","url":"https://micardi.github.io","root":"/"},"pages":[{}],"posts":[{"title":"Goodbye,OI!","date":"2019-04-08T01:26:49.246Z","path":"2019/04/08/退役随笔/","text":"To Do List 加入信竞 √ Accomplish 拿到省一 √ Accomplish 去冬令营 √ Accomplish 进入省队… × Failed. My Trip in OI 2018.5从开昕那里借到了紫书！艰难地啃完了基本语法…… 2018.6给go爷打了一通电话！意外地成功加入信息竞赛！ 2018.7在去诸暨的火车上达哥教会了我结构体。满心欢喜以为自己学会了什么不得了的东西。达哥：恭喜你已经入门了！我：？？？才是入门吗…… 海亮真漂亮啊QwQ矿主家孩子的学校。 与盒子先生一起看了世界杯决赛！支持的球队决赛从没赢过QAQ 被小学生初中生吊打了一段时间…然后发现我可以吊打他们了QwQ","raw":"---\ntitle: Goodbye,OI!\ntop: 10000\ntags: \n- OI\ncategories: \n- 随笔\n---\n\n### To Do List\n\n1. 加入信竞  √ Accomplish\n2. 拿到省一  √ Accomplish\n3. 去冬令营  √ Accomplish\n4. 进入省队...\n\n× Failed.\n\n### My Trip in OI\n\n- 2018.5 \n从开昕那里借到了紫书！艰难地啃完了基本语法......\n![循环嵌套当初搞死我了QAQ](C:\\Users\\user\\Desktop\\blog\\source\\image\\jc.jpg)\n\n- 2018.6 \n给go爷打了一通电话！意外地成功加入信息竞赛！\n\n- 2018.7 \n在去诸暨的火车上达哥教会了我结构体。满心欢喜以为自己学会了什么不得了的东西。\n达哥：恭喜你已经入门了！\n我：？？？才是入门吗......\n\n海亮真漂亮啊QwQ矿主家孩子的学校。\n![调的很失真QAQ不过很喜欢QwQ暴雨将至](C:\\Users\\user\\Desktop\\blog\\source\\image\\hl1.jpg)\n![天气很好！](C:\\Users\\user\\Desktop\\blog\\source\\image\\hl2.jpg)\n![这真的不是度假村吗...](C:\\Users\\user\\Desktop\\blog\\source\\image\\hl3.jpg)\n![别人家的学校(╯‵□′)╯︵┻━┻](C:\\Users\\user\\Desktop\\blog\\source\\image\\hl4.jpg)\n\n与盒子先生一起看了世界杯决赛！支持的球队决赛从没赢过QAQ\n![Danbo和他的电脑](C:\\Users\\user\\Desktop\\blog\\source\\image\\sjb.jpg)\n\n被小学生初中生吊打了一段时间...然后发现我可以吊打他们了QwQ\n![当即兴奋地合影留念QwQ](C:\\Users\\user\\Desktop\\blog\\source\\image\\kscj.jpg)\n![坚持下去就有可能](C:\\Users\\user\\Desktop\\blog\\source\\image\\jcxq.jpg)","content":"<h3 id=\"To-Do-List\"><a href=\"#To-Do-List\" class=\"headerlink\" title=\"To Do List\"></a>To Do List</h3><ol>\n<li>加入信竞  √ Accomplish</li>\n<li>拿到省一  √ Accomplish</li>\n<li>去冬令营  √ Accomplish</li>\n<li>进入省队…</li>\n</ol>\n<p>× Failed.</p>\n<h3 id=\"My-Trip-in-OI\"><a href=\"#My-Trip-in-OI\" class=\"headerlink\" title=\"My Trip in OI\"></a>My Trip in OI</h3><ul>\n<li><p>2018.5<br>从开昕那里借到了紫书！艰难地啃完了基本语法……<br><img src=\"C:\\Users\\user\\Desktop\\blog\\source\\image\\jc.jpg\" alt=\"循环嵌套当初搞死我了QAQ\"></p>\n</li>\n<li><p>2018.6<br>给go爷打了一通电话！意外地成功加入信息竞赛！</p>\n</li>\n<li><p>2018.7<br>在去诸暨的火车上达哥教会了我结构体。满心欢喜以为自己学会了什么不得了的东西。<br>达哥：恭喜你已经入门了！<br>我：？？？才是入门吗……</p>\n</li>\n</ul>\n<p>海亮真漂亮啊QwQ矿主家孩子的学校。<br><img src=\"C:\\Users\\user\\Desktop\\blog\\source\\image\\hl1.jpg\" alt=\"调的很失真QAQ不过很喜欢QwQ暴雨将至\"><br><img src=\"C:\\Users\\user\\Desktop\\blog\\source\\image\\hl2.jpg\" alt=\"天气很好！\"><br><img src=\"C:\\Users\\user\\Desktop\\blog\\source\\image\\hl3.jpg\" alt=\"这真的不是度假村吗...\"><br><img src=\"C:\\Users\\user\\Desktop\\blog\\source\\image\\hl4.jpg\" alt=\"别人家的学校(╯‵□′)╯︵┻━┻\"></p>\n<p>与盒子先生一起看了世界杯决赛！支持的球队决赛从没赢过QAQ<br><img src=\"C:\\Users\\user\\Desktop\\blog\\source\\image\\sjb.jpg\" alt=\"Danbo和他的电脑\"></p>\n<p>被小学生初中生吊打了一段时间…然后发现我可以吊打他们了QwQ<br><img src=\"C:\\Users\\user\\Desktop\\blog\\source\\image\\kscj.jpg\" alt=\"当即兴奋地合影留念QwQ\"><br><img src=\"C:\\Users\\user\\Desktop\\blog\\source\\image\\jcxq.jpg\" alt=\"坚持下去就有可能\"></p>\n","slug":"退役随笔","updated":"2019-04-08T02:49:54.880Z","link":"","permalink":"https://micardi.github.io/2019/04/08/退役随笔/","excerpt":"","categories":[{"name":"随笔","slug":"随笔","permalink":"https://micardi.github.io/categories/随笔/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://micardi.github.io/tags/OI/"}]},{"title":"一句话题解","date":"2019-03-29T12:30:00.785Z","path":"2019/03/29/一句话题解/","text":"做过的一些题目并无需细讲，却很值得人玩味，在此做个汇总，也算是方便自己复习整理咯QwQ. 【CEOI2015】世界冰球锦标赛 折半搜索【USACO10MAR】Test Taking 奇妙的分析【POI2011】TEM-temperature 单调队列【CQOI2006】简单题 真的好简单树状数组【NOI2014】动物园 KMP变种【SDOI2014】旅行 动态开点线段树+树剖【国家集训队】墨墨的等式 同余最短路【NOI2009】变换序列 倒着跑匈牙利【TJOI2018】数学计算 线段树 以时间为轴Period KMP求最小循环节【NOI2014】起床困难综合症 按位贪心灾后重建 对Floyd中转点的理解砝码称重 枚举+背包 可用bitset【HNOI2009】梦幻布丁 链表实现简易版splay【NOIp2013】火柴排队 树状数组【NOIp2015】子串 DP哈希冲突 对值域进行分块维护【HNOI2012】永无乡 splay+并查集+启发式合并【JSOI2008】星球大战 离线处理 断边-&gt;加边 并查集即可【HNOI2010】弹飞绵羊 标算LCT 分块瞎搞很interesting垃圾陷阱 背包变种 怎么这么少QAQ.","raw":"---\ntitle: 一句话题解\ntop: 9999\ntags: \n- OI\ncategories: \n- 题解\n---\n\n做过的一些题目并无需细讲，却很值得人玩味，在此做个汇总，也算是方便自己复习整理咯QwQ.\n\n[【CEOI2015】世界冰球锦标赛](https://www.luogu.org/problemnew/show/P4799) 折半搜索\n[【USACO10MAR】Test Taking](https://www.luogu.org/problemnew/show/P2988) 奇妙的分析\n[【POI2011】TEM-temperature](https://www.luogu.org/problemnew/show/P3522) 单调队列\n[【CQOI2006】简单题](https://www.luogu.org/problemnew/show/P5057) ~~真的好简单~~树状数组\n[【NOI2014】动物园](https://www.luogu.org/problemnew/show/P2375) KMP变种\n[【SDOI2014】旅行](https://www.luogu.org/problemnew/show/P3313) 动态开点线段树+树剖\n[【国家集训队】墨墨的等式](https://www.luogu.org/problemnew/show/P2371) 同余最短路\n[【NOI2009】变换序列](https://www.luogu.org/problemnew/show/P1963) 倒着跑匈牙利\n[【TJOI2018】数学计算](https://www.luogu.org/problemnew/show/P4588) 线段树 以时间为轴\n[Period](https://www.luogu.org/problemnew/show/SP263) KMP求最小循环节\n[【NOI2014】起床困难综合症](https://www.luogu.org/problemnew/show/P2114) 按位贪心\n[灾后重建](https://www.luogu.org/problemnew/show/P1119) 对Floyd中转点的理解\n[砝码称重](https://www.luogu.org/problemnew/show/P1441) 枚举+背包 可用bitset\n[【HNOI2009】梦幻布丁](https://www.luogu.org/problemnew/show/P3201) 链表实现简易版splay\n[【NOIp2013】火柴排队](https://www.luogu.org/problemnew/show/P1966) 树状数组\n[【NOIp2015】子串](https://www.luogu.org/problemnew/show/P2679) DP\n[哈希冲突](https://www.luogu.org/problemnew/show/P3396) 对值域进行分块维护\n[【HNOI2012】永无乡](https://www.luogu.org/problemnew/show/P3224) splay+并查集+启发式合并\n[【JSOI2008】星球大战](https://www.luogu.org/problemnew/show/P1197) 离线处理 断边->加边 并查集即可\n[【HNOI2010】弹飞绵羊](https://www.luogu.org/problemnew/show/P3203) 标算LCT 分块瞎搞很interesting\n[垃圾陷阱](https://www.luogu.org/problemnew/show/P1156) 背包变种\n\n怎么这么少QAQ.","content":"<p>做过的一些题目并无需细讲，却很值得人玩味，在此做个汇总，也算是方便自己复习整理咯QwQ.</p>\n<p><a href=\"https://www.luogu.org/problemnew/show/P4799\" target=\"_blank\" rel=\"noopener\">【CEOI2015】世界冰球锦标赛</a> 折半搜索<br><a href=\"https://www.luogu.org/problemnew/show/P2988\" target=\"_blank\" rel=\"noopener\">【USACO10MAR】Test Taking</a> 奇妙的分析<br><a href=\"https://www.luogu.org/problemnew/show/P3522\" target=\"_blank\" rel=\"noopener\">【POI2011】TEM-temperature</a> 单调队列<br><a href=\"https://www.luogu.org/problemnew/show/P5057\" target=\"_blank\" rel=\"noopener\">【CQOI2006】简单题</a> <del>真的好简单</del>树状数组<br><a href=\"https://www.luogu.org/problemnew/show/P2375\" target=\"_blank\" rel=\"noopener\">【NOI2014】动物园</a> KMP变种<br><a href=\"https://www.luogu.org/problemnew/show/P3313\" target=\"_blank\" rel=\"noopener\">【SDOI2014】旅行</a> 动态开点线段树+树剖<br><a href=\"https://www.luogu.org/problemnew/show/P2371\" target=\"_blank\" rel=\"noopener\">【国家集训队】墨墨的等式</a> 同余最短路<br><a href=\"https://www.luogu.org/problemnew/show/P1963\" target=\"_blank\" rel=\"noopener\">【NOI2009】变换序列</a> 倒着跑匈牙利<br><a href=\"https://www.luogu.org/problemnew/show/P4588\" target=\"_blank\" rel=\"noopener\">【TJOI2018】数学计算</a> 线段树 以时间为轴<br><a href=\"https://www.luogu.org/problemnew/show/SP263\" target=\"_blank\" rel=\"noopener\">Period</a> KMP求最小循环节<br><a href=\"https://www.luogu.org/problemnew/show/P2114\" target=\"_blank\" rel=\"noopener\">【NOI2014】起床困难综合症</a> 按位贪心<br><a href=\"https://www.luogu.org/problemnew/show/P1119\" target=\"_blank\" rel=\"noopener\">灾后重建</a> 对Floyd中转点的理解<br><a href=\"https://www.luogu.org/problemnew/show/P1441\" target=\"_blank\" rel=\"noopener\">砝码称重</a> 枚举+背包 可用bitset<br><a href=\"https://www.luogu.org/problemnew/show/P3201\" target=\"_blank\" rel=\"noopener\">【HNOI2009】梦幻布丁</a> 链表实现简易版splay<br><a href=\"https://www.luogu.org/problemnew/show/P1966\" target=\"_blank\" rel=\"noopener\">【NOIp2013】火柴排队</a> 树状数组<br><a href=\"https://www.luogu.org/problemnew/show/P2679\" target=\"_blank\" rel=\"noopener\">【NOIp2015】子串</a> DP<br><a href=\"https://www.luogu.org/problemnew/show/P3396\" target=\"_blank\" rel=\"noopener\">哈希冲突</a> 对值域进行分块维护<br><a href=\"https://www.luogu.org/problemnew/show/P3224\" target=\"_blank\" rel=\"noopener\">【HNOI2012】永无乡</a> splay+并查集+启发式合并<br><a href=\"https://www.luogu.org/problemnew/show/P1197\" target=\"_blank\" rel=\"noopener\">【JSOI2008】星球大战</a> 离线处理 断边-&gt;加边 并查集即可<br><a href=\"https://www.luogu.org/problemnew/show/P3203\" target=\"_blank\" rel=\"noopener\">【HNOI2010】弹飞绵羊</a> 标算LCT 分块瞎搞很interesting<br><a href=\"https://www.luogu.org/problemnew/show/P1156\" target=\"_blank\" rel=\"noopener\">垃圾陷阱</a> 背包变种</p>\n<p>怎么这么少QAQ.</p>\n","slug":"一句话题解","updated":"2019-03-29T13:28:34.716Z","link":"","permalink":"https://micardi.github.io/2019/03/29/一句话题解/","excerpt":"","categories":[{"name":"题解","slug":"题解","permalink":"https://micardi.github.io/categories/题解/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://micardi.github.io/tags/OI/"}]},{"title":"解决Xor问题的利器——线性基","date":"2019-03-29T11:35:09.805Z","path":"2019/03/29/线性基随笔/","text":"位运算是算法竞赛独特而有趣的一类知识，Xor（异或）则是相关题目中出现较为频繁的一种运算。 Xor具有以下特点/性质：交换律：a^b=b^a结合律：a^(b^c)=(a^b)^c自零性：a^a=0自反性：若a^b=c,则c^b=a,c^a=b 而在Xor一类题目中，我们常常会面对类似这样的问题：求出给定集合产生的所有异或值中最大/k大/最小/k小值。 我们知道，枚举所有子集的异或值复杂度为指数级别，难以处理集合规模较大的问题——不过我们注意到，所有子集产生的异或值会有许多重复的，我们要简化问题的关键就在于如何去重。我们就会有这样一个想法——能否构造出一个集合，使其既能保证与原集合异或值域相同，又能大大缩小集合规模呢？于是——线性基，应运而生了。 什么是线性基？“基”的概念来源于线性代数，线性空间中任意一个元素都可以唯一地表示成基向量的线性组合。 而线性基是一种特殊的基。一个集合的线性基具有如下基本性质： 其子集的异或值域与原集合的异或值域相同 线性基是所有满足第一条性质的集合中最小的集合 线性基无法通过异或得到0 如何构造线性基？我们通常用数组p来表示线性基。其中p[i]表示：二进制最高位的1在第i位的数。1234567891011121314#define ll long longconst int N=64;ll p[N];inline void ins(ll x)//向线性基中插入x&#123; for(int j=63;~j;--j) &#123; if(x&gt;&gt;j&amp;1)//如果x第j位为1 &#123; if(!p[j])&#123;p[j]=x;break;&#125;//p[j]尚未存在，那么直接令p[j]=x，不要忘记break else x^=p[j];//否则就让x异或上当前的p[j]，继续 &#125; &#125;&#125; 考虑这样构造为什么能维护三个基本性质。 对于性质一：上述方法构造出的线性基之所以能维护性质一，在于该线性基能表示出原集合中的每一个数。 设原集合为x1、x2、x3……xn，现在x1已经被插入线性基，我们插入x2。 如果x1与x2最高位的1不在同一位上，比如x1=4(100),x2=2(010),由上述构造方法知：x1不会对x2产生影响，x2被顺利插入。 如果x1与x2最高位的1在同一位上，比如x1=4(100),x2=6(110),那么x2会与x1进行Xor运算。设y=x1^x2,由Xor的自反性知x2=x1^y,那么x2就可以用x1^y表示出来。插入x3、x4……xn同理。因此我们可以用一组线性基表示出原集合中的所有数，进而可以得到原集合中的所有异或值。 对于性质二：这还是非常显然的。 我们在构造线性基时，会不断进行Xor的操作，如果一个数x经过不断Xor后变为0，说明这个数可以由线性基中若干个数表示出来——因为由Xor自零性知，只有当(p[i]^p[j]^p[k]^…^p[w])==x时，x才会变成0。而当且仅当这种情况下x才不会被插入线性基——换句话说，如果一个数被插入了线性基，说明这个数无法用其他数经过Xor得到。因此，线性基中的每一个数都无法删去或者合并，因为若被删去或者合并，这个数就没办法表示出来了。所以线性基是满足性质一的最小集合，进而保证了性质二成立。 对于性质三：前两条性质一旦保证，第三条性质也呼之欲出了。 假设线性基可以通过相互Xor得到0，那么一定有(p[i]^p[j]^…^p[k])==(p[a]^p[b]^…^p[c]),由Xor自反性知，有(p[i]^p[j]^p[k]^p[a]^…^p[b])==p[c]，即p[c]可以用其它的基表示出来，与性质二冲突，假设不成立。 了解了基本性质与构造方法后，我们就可以用线性基去解决一些题目了。至于线性基的一些特殊性质，我们就结合题目来理解吧： 例题 最大异或和 线性基模板题。 一个很显然的贪心：我们从高位到低位遍历线性基，若当前ans与当前p[i]进行Xor操作后变大了，我们就令ans=(ans^p[i])。贪心正确性？对于线性基中每一个p[i]以及任意j&lt;i，一定有p[j]第i位为0——结合构造方法，这个性质不难想到。那么我们每次都尽量保证当前最高位更大，之后在低位一定不会对高位有影响。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const int N=55;int n;ll a[N],p[107];ll read()&#123; ll f=1,a=0;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;a=(a&lt;&lt;3)+(a&lt;&lt;1)+ch-'0';ch=getchar();&#125; return a*f;&#125;inline void Xian_Xing_Ji(ll x) &#123; for(register ll i=60;i&gt;=0;--i) &#123; if(!(x&gt;&gt;i))continue; else &#123; if(!p[i])&#123; p[i]=x; break; &#125; else x^=p[i]; &#125; &#125;&#125;int main()&#123; n=read(); for(register int i=1;i&lt;=n;++i) Xian_Xing_Ji(a[i]=read()); ll ans=0; for(register int i=60;i&gt;=0;--i) if((ans^p[i])&gt;ans)ans^=p[i]; cout&lt;&lt;ans; return 0;&#125; k大异或和 线性基模板题。不过显然没有上题那么模板化——而且题目叫“k小异或和”似乎妥当一些。 首先我们需要介绍一个特殊性质：线性基中的元素相互Xor，线性基Xor值域不变——比如，设线性基中有元素x,y,现在令x=x^y,那么由Xor的自反性知，原来的x依旧可以用现在的x异或y得到，所以原来线性基的异或集合是不会变的。知道这个性质有什么用？本题需要利用这个性质对常规线性基进行改造。 我们令p[i]的意义稍稍改变一下：p[i]表示原Xor集合中，最高位的1在第i位的所有数中最小的一个。例如：若原Xor集合中最高位的1在第3位的有5(101),6(110),那么p[2]就应该等于5。接下来，我们要用一个数组a记录非空空的p——比如，p[0]=1,p[1]=0,p[2]=5,我们就要去掉p[1]——因为空的线性基显然不会对答案有贡献，这样就变成了a[0]=1,a[1]=5。然后，我们对k进行二进制拆分：若k二进制第i位为1，那么就让当前ans^p[i]，最后的ans就是所求了。 为什么这么做？我们借助一个例子理解一下：我们可以用10进制联想：第15小的正整数是谁？十位上第1小的(10)加上各位上第五小的(5)——二进制也同理。若k=5(101)，其实就是要求(非空)第2位上第一小的数Xor上第0位上第一小的数，就是a[2]^a[0]了(想一想，为什么是非空)。 这道题还有两个需要注意的地方： 怎么求改造后的p[i]？从高位到低位遍历原始线性基，对于每一个p[i]，若其第j位(j&lt;i)为1，就让p[i]=p[i]^p[j]。如何保证这样得到的p[i]是第i位中最小的？这里偷个懒……就不给详细解释了，大家感性理解：这样构造的话我们是让p[i]中比第i位低的1都尽量变成0——我们如何找十进制百位最小的数？显然让是比百位低的位上都为0。二进制也同理，我们要找当前Xor集合中第i位为1的最小数，自然也是尽量让比第i位低的位上都为0啊。同时，由前文所述特殊性质知，这样改造出的线性基与原集合Xor集合仍然相同。 由于线性基无法通过Xor得到0，所以若原集合可以通过Xor得到0，那么我们所求原集合中第k小实际上是线性基中的第k-1小。怎么判断原集合能否通过Xor得到0？若构造出线性基后发现线性基中的数比原集合中的数少，说明原集合可以通过相互Xor得到0——为什么？若原集合中的数相互Xor能得到0，一定有(x1^x2^…^xn)==0,即(x1^…^x2)==xn,那么由基本性质二可知，xn无法被插入线性基，线性基中数的个数就会比原集合中的数少。 然后我们就可以水过这道题了：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;#define ll long long using namespace std;ll p[64],a[64],x,k;int n,m,cnt=0;inline void ins(ll x)&#123; for(int j=50;~j;--j) &#123; if(x&gt;&gt;j&amp;1) &#123; if(!p[j])&#123;p[j]=x;break;&#125; else x^=p[j]; &#125; &#125;&#125;int main()&#123; scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;++i) &#123; scanf(\"%lld\",&amp;x); ins(x); &#125; for(int i=50;~i;--i) for(int j=i-1;~j;--j) if(p[i]&gt;&gt;j&amp;1)p[i]^=p[j]; for(int i=0;i&lt;=50;++i) if(p[i])a[cnt++]=p[i]; scanf(\"%d\",&amp;m); while(m--) &#123; scanf(\"%lld\",&amp;k); if(cnt!=n)--k; if(k&gt;=(1ll&lt;&lt;cnt))puts(\"-1\"); else &#123; ll ans=0; for(int i=0;i&lt;cnt;++i) if(k&gt;&gt;i&amp;1)ans^=a[i]; printf(\"%lld\\n\",ans); &#125; &#125; return 0;&#125; CQOI2013新Nim游戏 很有意思的一道线性基题目。 我们首先要知道传统Nim游戏如何判断胜负：设火柴堆数分别为x1、x2…xn，那么先手必胜当且仅当x1^x2^…^xn不为0，否则先手必败。具体证明属于博弈论相关，在此不再赘述。这道题与传统Nim游戏不一样的地方在于，第一轮双方是可以随便拿整堆火柴的——那么若要先手必胜，先手方必须留下一个局面，使得后手无论怎么做都无法令剩下的所有石子异或为0。集合内所有子集Xor值均不为0？一眼线性基噢！只要先手方留给后手方一个线性基，那不就是先手必胜了吗? 做法就很显然了：对于每一堆火柴，我们判断它是否可以被插入线性基，若可以就插入，否则就把这一堆石子取走。有一个需要注意的地方：题目还要求拿走的火柴数目的最小？我们可以贪心：将火柴堆数从大到小排列后进行上述操作。为什么是从大到小？我们这么想：我们肯定要先让大的数都尽量插入线性基，这样等到不得不拿走火柴的时候，拿走的就都是小的了。自己举几个例子，相信并不难理解。 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const int N=107;ll p[64],a[N];int k;inline bool ins(ll x)&#123; for(register int i=63;~i;--i)&#123; if(x&gt;&gt;i&amp;1)&#123; if(!p[i])&#123; p[i]=x; return true; &#125; else x^=p[i]; &#125; &#125; return false;&#125;ll ans;int main()&#123; scanf(\"%d\",&amp;k); for(register int i=1;i&lt;=k;++i) scanf(\"%lld\",&amp;a[i]); sort(a+1,a+k+1); for(register int i=k;i;--i) if(!ins(a[i]))ans+=a[i]; cout&lt;&lt;(ll)ans; return 0;&#125; -albus就是要第一个出场 又是一道需要用到一个特殊性质的题。我们设线性基非空长度为k(如p[0]=1,p[2]=4,p[5]=32,则k=3)，则线性基所能表示的Xor集合里共有2的k次方个不相同的数——这个很显然，每一个基都有选或不选两种可能。而设原集合长度为n，则每一种Xor值都出现了2的n-k次方次。这是为什么？我们可以这么考虑：因为原集合的线性基可以表示出所有Xor值，所以除了k个基以外，其它的n-k个数对Xor值并没有贡献，因此我们可以把它们都看成0；与此同时，k个基每产生一个异或值，都可以与这n-k个0继续Xor——从n-k个0中选择若干个零有几种方案呢？2的n-k次方种。 接下来我们要求给定的Q是第几大——我们依旧对线性基进行一个小小改造，我们用一个数组b存储非空p[i]的i(比如p[0]=1,p[1]=0,p[2]=4,则b[0]=0,b[1]=2),如果Q二进制中第b[i]位为1，则对答案贡献为2的i次方——因为说明到第i位时，是有这么多Xor值是比Q小的。每种Xor值都出现了2的(n-k)次方次，快速幂在最后处理即可。最后答案要+1，因为之前我们求的是有多少Xor值比Q小，加上1才是我们想要的排名。1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;#define ll long long#define mod 10086using namespace std;const int N=2e5+7;ll p[63],a[N],b[N];int n,k,tot,sum;inline void ins(ll x)&#123; for(register int i=63;~i;--i)&#123; if(x&gt;&gt;i&amp;1)&#123; if(!p[i])&#123; p[i]=x; break; &#125; else x^=p[i]; &#125; &#125;&#125;ll qpow(ll a,ll b)&#123; ll ans=1; while(b)&#123; if(b&amp;1)ans=(a*ans)%mod; b&gt;&gt;=1; a=(a*a)%mod; &#125; return ans;&#125;int main()&#123; scanf(\"%d\",&amp;n); for(register int i=1;i&lt;=n;++i)scanf(\"%lld\",&amp;a[i]),ins(a[i]); scanf(\"%d\",&amp;k); for(register int i=0;i&lt;64;++i) if(p[i])b[tot++]=i; for(register int i=0;i&lt;tot;++i) if(k&gt;&gt;b[i]&amp;1)sum+=1ll&lt;&lt;i; cout&lt;&lt;(1ll*sum*qpow(2,n-tot)+1)%mod; return 0;&#125;","raw":"---\ntitle: 解决Xor问题的利器——线性基\ntop: 1\ntags: \n- OI\n- 位运算\n- 线性基\ncategories: \n- 学习笔记\n---\n\n\n位运算是算法竞赛独特而有趣的一类知识，Xor（异或）则是相关题目中出现较为频繁的一种运算。\n\nXor具有以下特点/性质：\n交换律：a^b=b^a\n结合律：a^(b^c)=(a^b)^c\n自零性：a^a=0\n自反性：若a^b=c,则c^b=a,c^a=b\n\n而在Xor一类题目中，我们常常会面对类似这样的问题：求出给定集合产生的所有异或值中最大/k大/最小/k小值。\n\n我们知道，枚举所有子集的异或值复杂度为指数级别，难以处理集合规模较大的问题——不过我们注意到，所有子集产生的异或值会有许多重复的，我们要简化问题的关键就在于如何去重。\n我们就会有这样一个想法——能否构造出一个集合，使其既能保证与原集合异或值域相同，又能大大缩小集合规模呢？\n于是——线性基，应运而生了。\n\n---\n\n### 什么是线性基？\n\n“基”的概念来源于线性代数，线性空间中任意一个元素都可以唯一地表示成基向量的线性组合。\n\n而线性基是一种特殊的基。一个集合的线性基具有如下基本性质：\n- 其子集的异或值域与原集合的异或值域相同\n- 线性基是所有满足第一条性质的集合中最小的集合\n- 线性基无法通过异或得到0\n\n---\n\n### 如何构造线性基？\n\n我们通常用数组p来表示线性基。其中p[i]表示：二进制最高位的1在第i位的数。\n```cpp\n#define ll long long\nconst int N=64;\nll p[N];\ninline void ins(ll x)//向线性基中插入x\n{\n\tfor(int j=63;~j;--j)\n\t{\n        if(x>>j&1)//如果x第j位为1\n\t\t{\n        \tif(!p[j]){p[j]=x;break;}//p[j]尚未存在，那么直接令p[j]=x，不要忘记break\n            else x^=p[j];//否则就让x异或上当前的p[j]，继续\n        }\n    }\n}\n```\n\n考虑这样构造为什么能维护三个基本性质。\n\n- 对于性质一：\n上述方法构造出的线性基之所以能维护性质一，在于该线性基能表示出原集合中的每一个数。\n\n设原集合为x1、x2、x3......xn，现在x1已经被插入线性基，我们插入x2。\n1. 如果x1与x2最高位的1不在同一位上，比如x1=4(100),x2=2(010),由上述构造方法知：x1不会对x2产生影响，x2被顺利插入。\n2. 如果x1与x2最高位的1在同一位上，比如x1=4(100),x2=6(110),那么x2会与x1进行Xor运算。设y=x1^x2,由Xor的自反性知x2=x1^y,那么x2就可以用x1^y表示出来。\n插入x3、x4......xn同理。因此我们可以用一组线性基表示出原集合中的所有数，进而可以得到原集合中的所有异或值。\n\n- 对于性质二：\n这还是非常显然的。\n\n我们在构造线性基时，会不断进行Xor的操作，如果一个数x经过不断Xor后变为0，说明这个数可以由线性基中若干个数表示出来——因为由Xor自零性知，只有当(p[i]^p[j]^p[k]^...^p[w])==x时，x才会变成0。而当且仅当这种情况下x才不会被插入线性基——换句话说，如果一个数被插入了线性基，说明这个数无法用其他数经过Xor得到。\n因此，线性基中的每一个数都无法删去或者合并，因为若被删去或者合并，这个数就没办法表示出来了。所以线性基是满足性质一的最小集合，进而保证了性质二成立。\n\n- 对于性质三：\n前两条性质一旦保证，第三条性质也呼之欲出了。\n\n假设线性基可以通过相互Xor得到0，那么一定有(p[i]^p[j]^...^p[k])==(p[a]^p[b]^...^p[c]),由Xor自反性知，有(p[i]^p[j]^p[k]^p[a]^...^p[b])==p[c]，即p[c]可以用其它的基表示出来，与性质二冲突，假设不成立。\n\n了解了基本性质与构造方法后，我们就可以用线性基去解决一些题目了。至于线性基的一些特殊性质，我们就结合题目来理解吧：\n\n---\n\n### 例题\n\n- [最大异或和](https://loj.ac/problem/113)\n\n线性基模板题。\n\n一个很显然的贪心：我们从高位到低位遍历线性基，若当前ans与当前p[i]进行Xor操作后变大了，我们就令ans=(ans^p[i])。\n贪心正确性？\n对于线性基中每一个p[i]以及任意j<i，一定有p[j]第i位为0——结合构造方法，这个性质不难想到。那么我们每次都尽量保证当前最高位更大，之后在低位一定不会对高位有影响。\n\n```cpp\n#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\n\nconst int N=55;\n\nint n;\nll a[N],p[107];\n\nll read()\n{\n    ll f=1,a=0;char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){a=(a<<3)+(a<<1)+ch-'0';ch=getchar();}\n    return a*f;\n}\n\ninline void Xian_Xing_Ji(ll x) \n{\n    for(register ll i=60;i>=0;--i)\n    {\n        if(!(x>>i))continue;\n        else\n        {\n            if(!p[i]){\n                p[i]=x;\n                break;\n            }\n            else x^=p[i];\n        }\n    }\n}\n\nint main()\n{\n    n=read();\n    for(register int i=1;i<=n;++i)\n    Xian_Xing_Ji(a[i]=read());\n    \n    ll ans=0;\n    \n    for(register int i=60;i>=0;--i)\n    if((ans^p[i])>ans)ans^=p[i];\n    cout<<ans;\n    return 0;\n}\n```\n\n- [k大异或和](https://loj.ac/problem/114)\n\n线性基模板题。不过显然没有上题那么模板化——而且题目叫“k小异或和”似乎妥当一些。\n\n首先我们需要介绍一个特殊性质：线性基中的元素相互Xor，线性基Xor值域不变——比如，设线性基中有元素x,y,现在令x=x^y,那么由Xor的自反性知，原来的x依旧可以用现在的x异或y得到，所以原来线性基的异或集合是不会变的。\n知道这个性质有什么用？本题需要利用这个性质对常规线性基进行改造。\n\n我们令p[i]的意义稍稍改变一下：p[i]表示原Xor集合中，最高位的1在第i位的所有数中最小的一个。例如：若原Xor集合中最高位的1在第3位的有5(101),6(110),那么p[2]就应该等于5。\n接下来，我们要用一个数组a记录非空空的p——比如，p[0]=1,p[1]=0,p[2]=5,我们就要去掉p[1]——因为空的线性基显然不会对答案有贡献，这样就变成了a[0]=1,a[1]=5。\n然后，我们对k进行二进制拆分：若k二进制第i位为1，那么就让当前ans^p[i]，最后的ans就是所求了。\n\n为什么这么做？我们借助一个例子理解一下：\n我们可以用10进制联想：第15小的正整数是谁？十位上第1小的(10)加上各位上第五小的(5)——二进制也同理。若k=5(101)，其实就是要求(非空)第2位上第一小的数Xor上第0位上第一小的数，就是a[2]^a[0]了(想一想，为什么是非空)。\n\n这道题还有两个需要注意的地方：\n1. 怎么求改造后的p[i]？\n从高位到低位遍历原始线性基，对于每一个p[i]，若其第j位(j<i)为1，就让p[i]=p[i]^p[j]。\n如何保证这样得到的p[i]是第i位中最小的？\n这里偷个懒......就不给详细解释了，大家感性理解：这样构造的话我们是让p[i]中比第i位低的1都尽量变成0——我们如何找十进制百位最小的数？显然让是比百位低的位上都为0。二进制也同理，我们要找当前Xor集合中第i位为1的最小数，自然也是尽量让比第i位低的位上都为0啊。\n同时，由前文所述特殊性质知，这样改造出的线性基与原集合Xor集合仍然相同。\n\n2. 由于线性基无法通过Xor得到0，所以若原集合可以通过Xor得到0，那么我们所求原集合中第k小实际上是线性基中的第k-1小。\n怎么判断原集合能否通过Xor得到0？若构造出线性基后发现线性基中的数比原集合中的数少，说明原集合可以通过相互Xor得到0——为什么？若原集合中的数相互Xor能得到0，一定有(x1^x2^...^xn)==0,即(x1^...^x2)==xn,那么由基本性质二可知，xn无法被插入线性基，线性基中数的个数就会比原集合中的数少。\n\n然后我们就可以水过这道题了：\n```cpp\n#include<bits/stdc++.h>\n#define ll long long \nusing namespace std;\nll p[64],a[64],x,k;\nint n,m,cnt=0;\ninline void ins(ll x)\n{\n\tfor(int j=50;~j;--j)\n\t{\n        if(x>>j&1)\n\t\t{\n        \tif(!p[j]){p[j]=x;break;}\n            else x^=p[j];\n        }\n    }\n}\nint main()\n{\n   \n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;++i)\n\t{\n        scanf(\"%lld\",&x);\n        ins(x);\n    }\n    \n    for(int i=50;~i;--i)\n    for(int j=i-1;~j;--j)\n    if(p[i]>>j&1)p[i]^=p[j];\n    \n    for(int i=0;i<=50;++i)\n\tif(p[i])a[cnt++]=p[i];\n\t\n    scanf(\"%d\",&m);\n    \n    while(m--)\n\t{ \t\n        scanf(\"%lld\",&k);\n        if(cnt!=n)--k;\n        if(k>=(1ll<<cnt))puts(\"-1\");\n        else\n\t\t{\n            ll ans=0;\n            for(int i=0;i<cnt;++i)\n                if(k>>i&1)ans^=a[i];\n            printf(\"%lld\\n\",ans);\n        }\n    }\n    return 0;\n}\n```\n\n- [CQOI2013新Nim游戏](https://www.luogu.org/problemnew/show/P4301)\n\n很有意思的一道线性基题目。\n\n我们首先要知道传统Nim游戏如何判断胜负：设火柴堆数分别为x1、x2...xn，那么先手必胜当且仅当x1^x2^...^xn不为0，否则先手必败。具体证明属于博弈论相关，在此不再赘述。\n这道题与传统Nim游戏不一样的地方在于，第一轮双方是可以随便拿整堆火柴的——那么若要先手必胜，先手方必须留下一个局面，使得后手无论怎么做都无法令剩下的所有石子异或为0。\n集合内所有子集Xor值均不为0？一眼线性基噢！只要先手方留给后手方一个线性基，那不就是先手必胜了吗?\n\n做法就很显然了：对于每一堆火柴，我们判断它是否可以被插入线性基，若可以就插入，否则就把这一堆石子取走。\n有一个需要注意的地方：题目还要求拿走的火柴数目的最小？我们可以贪心：将火柴堆数从大到小排列后进行上述操作。\n为什么是从大到小？我们这么想：我们肯定要先让大的数都尽量插入线性基，这样等到不得不拿走火柴的时候，拿走的就都是小的了。自己举几个例子，相信并不难理解。\n\n```cpp\n#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\n\nconst int N=107;\n\nll p[64],a[N];\nint k;\n\ninline bool ins(ll x){\n    for(register int i=63;~i;--i){\n        if(x>>i&1){\n            if(!p[i]){\n                p[i]=x;\n                return true;\n            } \n            else x^=p[i];\n        }\n    }\n    return false;\n}\n\nll ans;\n\nint main()\n{\n    scanf(\"%d\",&k);\n    for(register int i=1;i<=k;++i)\n    scanf(\"%lld\",&a[i]);\n    \n    sort(a+1,a+k+1);\n    \n    for(register int i=k;i;--i)\n    if(!ins(a[i]))ans+=a[i];\n    \n    cout<<(ll)ans;\n    return 0;\n}\n```\n\n-[albus就是要第一个出场](https://www.luogu.org/problemnew/show/P4869)\n\n又是一道需要用到一个特殊性质的题。\n我们设线性基非空长度为k(如p[0]=1,p[2]=4,p[5]=32,则k=3)，则线性基所能表示的Xor集合里共有2的k次方个不相同的数——这个很显然，每一个基都有选或不选两种可能。而设原集合长度为n，则每一种Xor值都出现了2的n-k次方次。\n这是为什么？我们可以这么考虑：因为原集合的线性基可以表示出所有Xor值，所以除了k个基以外，其它的n-k个数对Xor值并没有贡献，因此我们可以把它们都看成0；与此同时，k个基每产生一个异或值，都可以与这n-k个0继续Xor——从n-k个0中选择若干个零有几种方案呢？2的n-k次方种。\n\n接下来我们要求给定的Q是第几大——我们依旧对线性基进行一个小小改造，我们用一个数组b存储非空p[i]的i(比如p[0]=1,p[1]=0,p[2]=4,则b[0]=0,b[1]=2),如果Q二进制中第b[i]位为1，则对答案贡献为2的i次方——因为说明到第i位时，是有这么多Xor值是比Q小的。\n每种Xor值都出现了2的(n-k)次方次，快速幂在最后处理即可。\n最后答案要+1，因为之前我们求的是有多少Xor值比Q小，加上1才是我们想要的排名。\n```cpp\n#include<bits/stdc++.h>\n#define ll long long\n#define mod 10086\nusing namespace std;\n\nconst int N=2e5+7;\n\nll p[63],a[N],b[N];\nint n,k,tot,sum;\n\ninline void ins(ll x){\n    for(register int i=63;~i;--i){\n        if(x>>i&1){\n            if(!p[i]){\n                p[i]=x;\n                break;\n            }\n            else x^=p[i];\n        }\n    }\n}\n\nll qpow(ll a,ll b){\n    ll ans=1;\n    while(b){\n        if(b&1)ans=(a*ans)%mod;\n        b>>=1;\n        a=(a*a)%mod;\n    }\n    return ans;\n}\n\nint main(){\n    scanf(\"%d\",&n);\n    for(register int i=1;i<=n;++i)scanf(\"%lld\",&a[i]),ins(a[i]);\n    scanf(\"%d\",&k);\n    for(register int i=0;i<64;++i)\n    if(p[i])b[tot++]=i;\n    for(register int i=0;i<tot;++i)\n    if(k>>b[i]&1)sum+=1ll<<i;\n        \n    cout<<(1ll*sum*qpow(2,n-tot)+1)%mod;\n    return 0;\n} \n```","content":"<p>位运算是算法竞赛独特而有趣的一类知识，Xor（异或）则是相关题目中出现较为频繁的一种运算。</p>\n<p>Xor具有以下特点/性质：<br>交换律：a^b=b^a<br>结合律：a^(b^c)=(a^b)^c<br>自零性：a^a=0<br>自反性：若a^b=c,则c^b=a,c^a=b</p>\n<p>而在Xor一类题目中，我们常常会面对类似这样的问题：求出给定集合产生的所有异或值中最大/k大/最小/k小值。</p>\n<p>我们知道，枚举所有子集的异或值复杂度为指数级别，难以处理集合规模较大的问题——不过我们注意到，所有子集产生的异或值会有许多重复的，我们要简化问题的关键就在于如何去重。<br>我们就会有这样一个想法——能否构造出一个集合，使其既能保证与原集合异或值域相同，又能大大缩小集合规模呢？<br>于是——线性基，应运而生了。</p>\n<hr>\n<h3 id=\"什么是线性基？\"><a href=\"#什么是线性基？\" class=\"headerlink\" title=\"什么是线性基？\"></a>什么是线性基？</h3><p>“基”的概念来源于线性代数，线性空间中任意一个元素都可以唯一地表示成基向量的线性组合。</p>\n<p>而线性基是一种特殊的基。一个集合的线性基具有如下基本性质：</p>\n<ul>\n<li>其子集的异或值域与原集合的异或值域相同</li>\n<li>线性基是所有满足第一条性质的集合中最小的集合</li>\n<li>线性基无法通过异或得到0</li>\n</ul>\n<hr>\n<h3 id=\"如何构造线性基？\"><a href=\"#如何构造线性基？\" class=\"headerlink\" title=\"如何构造线性基？\"></a>如何构造线性基？</h3><p>我们通常用数组p来表示线性基。其中p[i]表示：二进制最高位的1在第i位的数。<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ll long long</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> N=<span class=\"number\">64</span>;</span><br><span class=\"line\">ll p[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">ins</span><span class=\"params\">(ll x)</span><span class=\"comment\">//向线性基中插入x</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">63</span>;~j;--j)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(x&gt;&gt;j&amp;<span class=\"number\">1</span>)<span class=\"comment\">//如果x第j位为1</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">        \t<span class=\"keyword\">if</span>(!p[j])&#123;p[j]=x;<span class=\"keyword\">break</span>;&#125;<span class=\"comment\">//p[j]尚未存在，那么直接令p[j]=x，不要忘记break</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> x^=p[j];<span class=\"comment\">//否则就让x异或上当前的p[j]，继续</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>考虑这样构造为什么能维护三个基本性质。</p>\n<ul>\n<li>对于性质一：<br>上述方法构造出的线性基之所以能维护性质一，在于该线性基能表示出原集合中的每一个数。</li>\n</ul>\n<p>设原集合为x1、x2、x3……xn，现在x1已经被插入线性基，我们插入x2。</p>\n<ol>\n<li>如果x1与x2最高位的1不在同一位上，比如x1=4(100),x2=2(010),由上述构造方法知：x1不会对x2产生影响，x2被顺利插入。</li>\n<li>如果x1与x2最高位的1在同一位上，比如x1=4(100),x2=6(110),那么x2会与x1进行Xor运算。设y=x1^x2,由Xor的自反性知x2=x1^y,那么x2就可以用x1^y表示出来。<br>插入x3、x4……xn同理。因此我们可以用一组线性基表示出原集合中的所有数，进而可以得到原集合中的所有异或值。</li>\n</ol>\n<ul>\n<li>对于性质二：<br>这还是非常显然的。</li>\n</ul>\n<p>我们在构造线性基时，会不断进行Xor的操作，如果一个数x经过不断Xor后变为0，说明这个数可以由线性基中若干个数表示出来——因为由Xor自零性知，只有当(p[i]^p[j]^p[k]^…^p[w])==x时，x才会变成0。而当且仅当这种情况下x才不会被插入线性基——换句话说，如果一个数被插入了线性基，说明这个数无法用其他数经过Xor得到。<br>因此，线性基中的每一个数都无法删去或者合并，因为若被删去或者合并，这个数就没办法表示出来了。所以线性基是满足性质一的最小集合，进而保证了性质二成立。</p>\n<ul>\n<li>对于性质三：<br>前两条性质一旦保证，第三条性质也呼之欲出了。</li>\n</ul>\n<p>假设线性基可以通过相互Xor得到0，那么一定有(p[i]^p[j]^…^p[k])==(p[a]^p[b]^…^p[c]),由Xor自反性知，有(p[i]^p[j]^p[k]^p[a]^…^p[b])==p[c]，即p[c]可以用其它的基表示出来，与性质二冲突，假设不成立。</p>\n<p>了解了基本性质与构造方法后，我们就可以用线性基去解决一些题目了。至于线性基的一些特殊性质，我们就结合题目来理解吧：</p>\n<hr>\n<h3 id=\"例题\"><a href=\"#例题\" class=\"headerlink\" title=\"例题\"></a>例题</h3><ul>\n<li><a href=\"https://loj.ac/problem/113\" target=\"_blank\" rel=\"noopener\">最大异或和</a></li>\n</ul>\n<p>线性基模板题。</p>\n<p>一个很显然的贪心：我们从高位到低位遍历线性基，若当前ans与当前p[i]进行Xor操作后变大了，我们就令ans=(ans^p[i])。<br>贪心正确性？<br>对于线性基中每一个p[i]以及任意j&lt;i，一定有p[j]第i位为0——结合构造方法，这个性质不难想到。那么我们每次都尽量保证当前最高位更大，之后在低位一定不会对高位有影响。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ll long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> N=<span class=\"number\">55</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> n;</span><br><span class=\"line\">ll a[N],p[<span class=\"number\">107</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">read</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    ll f=<span class=\"number\">1</span>,a=<span class=\"number\">0</span>;<span class=\"keyword\">char</span> ch=getchar();</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(ch&lt;<span class=\"string\">'0'</span>||ch&gt;<span class=\"string\">'9'</span>)&#123;<span class=\"keyword\">if</span>(ch==<span class=\"string\">'-'</span>)f=<span class=\"number\">-1</span>;ch=getchar();&#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(ch&gt;=<span class=\"string\">'0'</span>&amp;&amp;ch&lt;=<span class=\"string\">'9'</span>)&#123;a=(a&lt;&lt;<span class=\"number\">3</span>)+(a&lt;&lt;<span class=\"number\">1</span>)+ch-<span class=\"string\">'0'</span>;ch=getchar();&#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a*f;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">Xian_Xing_Ji</span><span class=\"params\">(ll x)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">register</span> ll i=<span class=\"number\">60</span>;i&gt;=<span class=\"number\">0</span>;--i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!(x&gt;&gt;i))<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!p[i])&#123;</span><br><span class=\"line\">                p[i]=x;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> x^=p[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    n=read();</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">register</span> <span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;++i)</span><br><span class=\"line\">    Xian_Xing_Ji(a[i]=read());</span><br><span class=\"line\">    </span><br><span class=\"line\">    ll ans=<span class=\"number\">0</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">register</span> <span class=\"keyword\">int</span> i=<span class=\"number\">60</span>;i&gt;=<span class=\"number\">0</span>;--i)</span><br><span class=\"line\">    <span class=\"keyword\">if</span>((ans^p[i])&gt;ans)ans^=p[i];</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;ans;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><a href=\"https://loj.ac/problem/114\" target=\"_blank\" rel=\"noopener\">k大异或和</a></li>\n</ul>\n<p>线性基模板题。不过显然没有上题那么模板化——而且题目叫“k小异或和”似乎妥当一些。</p>\n<p>首先我们需要介绍一个特殊性质：线性基中的元素相互Xor，线性基Xor值域不变——比如，设线性基中有元素x,y,现在令x=x^y,那么由Xor的自反性知，原来的x依旧可以用现在的x异或y得到，所以原来线性基的异或集合是不会变的。<br>知道这个性质有什么用？本题需要利用这个性质对常规线性基进行改造。</p>\n<p>我们令p[i]的意义稍稍改变一下：p[i]表示原Xor集合中，最高位的1在第i位的所有数中最小的一个。例如：若原Xor集合中最高位的1在第3位的有5(101),6(110),那么p[2]就应该等于5。<br>接下来，我们要用一个数组a记录非空空的p——比如，p[0]=1,p[1]=0,p[2]=5,我们就要去掉p[1]——因为空的线性基显然不会对答案有贡献，这样就变成了a[0]=1,a[1]=5。<br>然后，我们对k进行二进制拆分：若k二进制第i位为1，那么就让当前ans^p[i]，最后的ans就是所求了。</p>\n<p>为什么这么做？我们借助一个例子理解一下：<br>我们可以用10进制联想：第15小的正整数是谁？十位上第1小的(10)加上各位上第五小的(5)——二进制也同理。若k=5(101)，其实就是要求(非空)第2位上第一小的数Xor上第0位上第一小的数，就是a[2]^a[0]了(想一想，为什么是非空)。</p>\n<p>这道题还有两个需要注意的地方：</p>\n<ol>\n<li><p>怎么求改造后的p[i]？<br>从高位到低位遍历原始线性基，对于每一个p[i]，若其第j位(j&lt;i)为1，就让p[i]=p[i]^p[j]。<br>如何保证这样得到的p[i]是第i位中最小的？<br>这里偷个懒……就不给详细解释了，大家感性理解：这样构造的话我们是让p[i]中比第i位低的1都尽量变成0——我们如何找十进制百位最小的数？显然让是比百位低的位上都为0。二进制也同理，我们要找当前Xor集合中第i位为1的最小数，自然也是尽量让比第i位低的位上都为0啊。<br>同时，由前文所述特殊性质知，这样改造出的线性基与原集合Xor集合仍然相同。</p>\n</li>\n<li><p>由于线性基无法通过Xor得到0，所以若原集合可以通过Xor得到0，那么我们所求原集合中第k小实际上是线性基中的第k-1小。<br>怎么判断原集合能否通过Xor得到0？若构造出线性基后发现线性基中的数比原集合中的数少，说明原集合可以通过相互Xor得到0——为什么？若原集合中的数相互Xor能得到0，一定有(x1^x2^…^xn)==0,即(x1^…^x2)==xn,那么由基本性质二可知，xn无法被插入线性基，线性基中数的个数就会比原集合中的数少。</p>\n</li>\n</ol>\n<p>然后我们就可以水过这道题了：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ll long long </span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\">ll p[<span class=\"number\">64</span>],a[<span class=\"number\">64</span>],x,k;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n,m,cnt=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">ins</span><span class=\"params\">(ll x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">50</span>;~j;--j)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(x&gt;&gt;j&amp;<span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">        \t<span class=\"keyword\">if</span>(!p[j])&#123;p[j]=x;<span class=\"keyword\">break</span>;&#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> x^=p[j];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;n);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;++i)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%lld\"</span>,&amp;x);</span><br><span class=\"line\">        ins(x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">50</span>;~i;--i)</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=i<span class=\"number\">-1</span>;~j;--j)</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(p[i]&gt;&gt;j&amp;<span class=\"number\">1</span>)p[i]^=p[j];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;=<span class=\"number\">50</span>;++i)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(p[i])a[cnt++]=p[i];</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;m);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">while</span>(m--)</span><br><span class=\"line\">\t&#123; \t</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%lld\"</span>,&amp;k);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(cnt!=n)--k;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(k&gt;=(<span class=\"number\">1l</span>l&lt;&lt;cnt))<span class=\"built_in\">puts</span>(<span class=\"string\">\"-1\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">            ll ans=<span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;cnt;++i)</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(k&gt;&gt;i&amp;<span class=\"number\">1</span>)ans^=a[i];</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%lld\\n\"</span>,ans);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><a href=\"https://www.luogu.org/problemnew/show/P4301\" target=\"_blank\" rel=\"noopener\">CQOI2013新Nim游戏</a></li>\n</ul>\n<p>很有意思的一道线性基题目。</p>\n<p>我们首先要知道传统Nim游戏如何判断胜负：设火柴堆数分别为x1、x2…xn，那么先手必胜当且仅当x1^x2^…^xn不为0，否则先手必败。具体证明属于博弈论相关，在此不再赘述。<br>这道题与传统Nim游戏不一样的地方在于，第一轮双方是可以随便拿整堆火柴的——那么若要先手必胜，先手方必须留下一个局面，使得后手无论怎么做都无法令剩下的所有石子异或为0。<br>集合内所有子集Xor值均不为0？一眼线性基噢！只要先手方留给后手方一个线性基，那不就是先手必胜了吗?</p>\n<p>做法就很显然了：对于每一堆火柴，我们判断它是否可以被插入线性基，若可以就插入，否则就把这一堆石子取走。<br>有一个需要注意的地方：题目还要求拿走的火柴数目的最小？我们可以贪心：将火柴堆数从大到小排列后进行上述操作。<br>为什么是从大到小？我们这么想：我们肯定要先让大的数都尽量插入线性基，这样等到不得不拿走火柴的时候，拿走的就都是小的了。自己举几个例子，相信并不难理解。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ll long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> N=<span class=\"number\">107</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">ll p[<span class=\"number\">64</span>],a[N];</span><br><span class=\"line\"><span class=\"keyword\">int</span> k;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"title\">ins</span><span class=\"params\">(ll x)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">register</span> <span class=\"keyword\">int</span> i=<span class=\"number\">63</span>;~i;--i)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(x&gt;&gt;i&amp;<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!p[i])&#123;</span><br><span class=\"line\">                p[i]=x;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125; </span><br><span class=\"line\">            <span class=\"keyword\">else</span> x^=p[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ll ans;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;k);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">register</span> <span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=k;++i)</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%lld\"</span>,&amp;a[i]);</span><br><span class=\"line\">    </span><br><span class=\"line\">    sort(a+<span class=\"number\">1</span>,a+k+<span class=\"number\">1</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">register</span> <span class=\"keyword\">int</span> i=k;i;--i)</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!ins(a[i]))ans+=a[i];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;(ll)ans;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>-<a href=\"https://www.luogu.org/problemnew/show/P4869\" target=\"_blank\" rel=\"noopener\">albus就是要第一个出场</a></p>\n<p>又是一道需要用到一个特殊性质的题。<br>我们设线性基非空长度为k(如p[0]=1,p[2]=4,p[5]=32,则k=3)，则线性基所能表示的Xor集合里共有2的k次方个不相同的数——这个很显然，每一个基都有选或不选两种可能。而设原集合长度为n，则每一种Xor值都出现了2的n-k次方次。<br>这是为什么？我们可以这么考虑：因为原集合的线性基可以表示出所有Xor值，所以除了k个基以外，其它的n-k个数对Xor值并没有贡献，因此我们可以把它们都看成0；与此同时，k个基每产生一个异或值，都可以与这n-k个0继续Xor——从n-k个0中选择若干个零有几种方案呢？2的n-k次方种。</p>\n<p>接下来我们要求给定的Q是第几大——我们依旧对线性基进行一个小小改造，我们用一个数组b存储非空p[i]的i(比如p[0]=1,p[1]=0,p[2]=4,则b[0]=0,b[1]=2),如果Q二进制中第b[i]位为1，则对答案贡献为2的i次方——因为说明到第i位时，是有这么多Xor值是比Q小的。<br>每种Xor值都出现了2的(n-k)次方次，快速幂在最后处理即可。<br>最后答案要+1，因为之前我们求的是有多少Xor值比Q小，加上1才是我们想要的排名。<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ll long long</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> mod 10086</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> N=<span class=\"number\">2e5</span>+<span class=\"number\">7</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">ll p[<span class=\"number\">63</span>],a[N],b[N];</span><br><span class=\"line\"><span class=\"keyword\">int</span> n,k,tot,sum;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">ins</span><span class=\"params\">(ll x)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">register</span> <span class=\"keyword\">int</span> i=<span class=\"number\">63</span>;~i;--i)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(x&gt;&gt;i&amp;<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!p[i])&#123;</span><br><span class=\"line\">                p[i]=x;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> x^=p[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">qpow</span><span class=\"params\">(ll a,ll b)</span></span>&#123;</span><br><span class=\"line\">    ll ans=<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(b)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(b&amp;<span class=\"number\">1</span>)ans=(a*ans)%mod;</span><br><span class=\"line\">        b&gt;&gt;=<span class=\"number\">1</span>;</span><br><span class=\"line\">        a=(a*a)%mod;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;n);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">register</span> <span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;++i)<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%lld\"</span>,&amp;a[i]),ins(a[i]);</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;k);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">register</span> <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">64</span>;++i)</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(p[i])b[tot++]=i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">register</span> <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;tot;++i)</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(k&gt;&gt;b[i]&amp;<span class=\"number\">1</span>)sum+=<span class=\"number\">1l</span>l&lt;&lt;i;</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;(<span class=\"number\">1l</span>l*sum*qpow(<span class=\"number\">2</span>,n-tot)+<span class=\"number\">1</span>)%mod;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","slug":"线性基随笔","updated":"2019-04-08T01:21:10.646Z","link":"","permalink":"https://micardi.github.io/2019/03/29/线性基随笔/","excerpt":"","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://micardi.github.io/categories/学习笔记/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://micardi.github.io/tags/OI/"},{"name":"位运算","slug":"位运算","permalink":"https://micardi.github.io/tags/位运算/"},{"name":"线性基","slug":"线性基","permalink":"https://micardi.github.io/tags/线性基/"}]}]}